///////////////////////////////////////////////////////////////////////////////
//                                                                             
// JTOpen (IBM Toolbox for Java - OSS version)                              
//                                                                             
// Filename: AS400ToolboxJarMaker.java
//                                                                             
// The source code contained herein is licensed under the IBM Public License   
// Version 1.0, which has been approved by the Open Source Initiative.         
// Copyright (C) 1997-2001 International Business Machines Corporation and     
// others. All rights reserved.                                                
//                                                                             
///////////////////////////////////////////////////////////////////////////////

package utilities;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.Vector;


/**
The AS400ToolboxJarMaker class is used to generate a smaller
JAR or ZIP file from the shipped <i>IBM Toolbox for Java</i>
JAR or ZIP file, based on the user's requirements.
<p>
In addition, AS400ToolboxJarMaker can also be used to:
<ul compact>
<li> <em>extract</em> desired files from a JAR or ZIP file; or
<li> <em>split</em> a JAR or ZIP file into smaller JAR or ZIP files.
</ul>
<p>
An AS400ToolboxJarMaker object can be included in the user's program,
or AS400ToolboxJarMaker can be run as a command line program, as follows:
<blockquote>
<pre>
<strong>java utilities.AS400ToolboxJarMaker</strong> [ options ]
</pre>
</blockquote>
AS400ToolboxJarMaker extends the functionality of JarMaker by
additionally allowing the user to specify one or more
<i>IBM Toolbox for Java</i> components,
languages, and/or CCSIDs, and whether or not to include
Java Beans files that are associated with the specified components.

<p>
<b><a name="asoptions">Options</a></b>

<p>
<dl>
<dt><b><code>-source </b></code><var>sourceJarFile</var>
<dd>
Specifies the source JAR or ZIP file from which to derive
the destination JAR or ZIP file.  The source file is expected to contain the IBM Toolbox for Java product, and is typically named <code>jt400.jar</code>.
To process a JAR or ZIP other than the Toolbox, use {@link JarMaker JarMaker}.
If a relative path is specified, the path is assumed to be relative to
the current directory.
If this option is specified as the first positional argument,
the tag (<code>-source</code>) is optional. 
The -source option may be abbreviated to -s.
The default is <code>jt400.jar</code>, in the current directory.

<p>
<dt><b><code>-destination </b></code><var>destinationJarFile</var>
<dd>
Specifies the destination JAR or ZIP file, which will contain
the desired subset of the files in the source JAR or ZIP file.
If a pathname is not specified, the file is created in the current directory.
The -destination option may be abbreviated to -d.
The default name is generated by appending <code>"Small"</code> to the
source file name.  For example, if the source file is <code>jt400.jar</code>,
then the default destination file would be <code>jt400Small.jar</code>.

<p>
<dt><b><code>-requiredFile </b></code><var>jarEntry1[,jarEntry2[...] ] </var>
<dd>
The files in the source JAR or ZIP file that are to be copied to the destination.
Entries are separated by commas (no spaces).
The specified files, along with all of their dependencies,
will be considered required.
Files are specified in JAR entry name syntax, such as <code>com/ibm/as400/access/DataQueue.class</code>.
The -requiredFile option may be abbreviated to -rf.

<p>
<dt><b><code>-additionalFile </b></code><var>file1[,file2[...] ] </var>
<dd>
Specifies additional files (not included in the source jar) which are
to be copied to the destination.
Entries are separated by commas (no spaces).
Files are specified by either their
absolute path, or their path relative to the current directory.
<br>The specified files will be included, regardless of the settings of
other options.
The -additionalFile option may be abbreviated to -af.

<p>
<dt><b><code>-additionalFilesDirectory </b></code><var>baseDirectory</var>
<dd>
Specifies the base directory for additional files.
This should be the parent directory of the
directory where the package path starts.  For example, if file <code>foo.class</code>
in package <code>com.ibm.mypackage</code> is located in directory
<code>C:\dir1\subdir2\com\ibm\mypackage\</code>, then specify base directory <code>C:\dir1\subdir2</code>.
<br>The -additionalFilesDirectory option may be abbreviated to -afd.
The default is the current directory.

<p>
<dt><b><code>-package </b></code><var>package1[,package2[...] ] </var>
<dd>
The packages that are required.
Entries are separated by commas (no spaces).
The -package option may be abbreviated to -p.
Package names are specified in standard syntax, such as <code>com.ibm.component</code>.
<br>Note: The specified packages are simply included in the output.
No additional dependency analysis is done on the files in a package,
unless they are explicitly specified as required files.

<p>
<dt><b><code>-extract </b></code><var>[baseDirectory]</var>
<dd>
Extracts the desired entries of the source JAR into the specified base directory,
without generating a new JAR or ZIP file.  This option enables the
user to build up a customized JAR or ZIP file empirically,
based on the requirements of their particular application.
When this option is specified, <code>-additionalFile</code>,
<code>-additionalFilesDirectory</code>, and <code>-destination</code>
are ignored.
The -extract option may be abbreviated to -x.
By default, no extraction is done.
The default base directory is the current directory.

<p>
<dt><b><code>-split </b></code><var>[splitSize]</var>
<dd>
Splits the source JAR or ZIP file into smaller JAR or ZIP files.
No ZIP entries are added or excluded;
the entries in the source JAR or ZIP file are simply distributed
among the destination JAR or ZIP files.
The split size is in units of kilobytes (1024 bytes),
and specifies the maximum size for the destination files.
The destination files are created in the current directory,
and are named by appending integers to the source file name;
any existing files by the same name are overwritten.
For example, if the source JAR file is <code>myfile.jar</code>,
then the destination JAR files would be
<code>myfile0.jar</code>, <code>myfile1.jar</code>, and so on.
When this option is specified, all other options except
<code>-source</code> and <code>-verbose</code> are ignored.
The -split option may be abbreviated to -sp.
The default split size is 2 megabytes (2048 kilobytes).

<p>
<dt><b><code>-component </b></code><var>componentID1[,componentID2[...] ] </var>
<dd>
The <i>IBM Toolbox for Java</i> components that are required.
Entries are separated by commas (no spaces), and are case insensitive.
The -component option may be abbreviated to -c.
<br>
See the list of <a href="../componentList.html">components</a>
that are supported by <i>IBM Toolbox for Java</i>.

<p>
<dt><b><code>-beans </b></code>
<dd>
Causes inclusion of all Java Beans files (classes, gifs) that are
directly associated with the specified components.
This option is valid only if <code>-component</code> is also specified.
The -beans option may be abbreviated to -b.
The default is no Beans.

<p>
<dt><b><code>-language </b></code><var>language1[,language2[...]]</var>
<dd>
Specifies the desired languages for the messages produced by the Toolbox classes.
Entries are separated by commas (no spaces).
The languages are identified by their Java locale name, such as fr_CA
(for Canadian French).
<br>Note: The shipped jt400.jar file contains only English messages.
The -language option may be abbreviated to -l.
By default, only English messages are included.

<p>
<dt><b><code>-languageDirectory </b></code><var>baseDirectory</var>
<dd>
Specifies the base directory for additional Toolbox language files.
The path below this directory should correspond to the package name
the language files.
For example, if the desired MRI files are located in directories
<code>/usr/myDir/com/ibm/as400/access/</code> and
<code>/usr/myDir/com/ibm/as400/vaccess/</code>,
then the base directory should be set to <code>/usr/myDir</code>.
<br>The -languageDirectory option may be abbreviated to -ld.
By default, language files are searched for relative to the
current directory.

<p>
<dt><b><code>-ccsid </b></code><var>ccsid1[,ccsid2[...]]</var>
<dd>
Specifies the CCSIDs whose conversion tables should be included.
Conversion tables for other CCSIDs will not be included.
Entries are separated by commas (no spaces).
The -ccsid option may be abbreviated to -cc.
By default, all CCSIDs are included.
See the list of <a href="../ccsidList.html">CCSIDs and encodings</a>
that are specifically supported by <i>IBM Toolbox for Java</i>.

<p>
<dt><b><code>-ccsidExcluded </b></code><var>ccsid1[,ccsid2[...]]</var>
<dd>
Specifies the CCSIDs whose conversion tables should <em>not</em> be included.
Entries are separated by commas (no spaces).  If a CCSID is specified on
both the <code>-ccsid</code> and <code>-ccsidExcluded</code>, it is included,
and a warning message is sent to <code>System.err</code>.
The -ccsidExcluded option may be abbreviated to -cx or -ccx.
By default, all CCSIDs are included.
See the list of <a href="../ccsidList.html">CCSIDs and encodings</a>
that are specifically supported by <i>IBM Toolbox for Java</i>.

<p>
<dt><b><code>-noProxy </b></code>
<dd>
Specifies that proxy-related class files should <em>not</em> be included.
Proxy files are used internally by the Toolbox's Proxy Service.
If the Proxy Service will not be used, the proxy files are not needed.
The -noProxy option may be abbreviated to -np.
By default, proxy files in the source JAR file are included.

<p>
<dt><b><code>-verbose </b></code>
<dd>
Causes progress messages to be displayed.
The -verbose option may be abbreviated to -v.
The default is non-verbose.

<p>
<dt><b><code>-help </b></code>
<dd>
Displays the help text.
The -help option may be abbreviated to -h.
The default is non-verbose.

</dl>

<p>
At least one of the following options must be specified:
<ul compact>
<li>-requiredFile
<li>-additionalFile
<li>-package
<li>-extract
<li>-split
<li>-component
<li>-language
<li>-ccsid
<li>-ccsidExcluded
<li>-noProxy
</ul>

<p>
If the following options are specified multiple times in a single command
string, only the final specification applies:
<ul compact>
<li>-source
<li>-destination
<li>-additionalFilesDirectory
<li>-extract
<li>-split
<li>-languageDirectory
</ul>
Other options have a cumulative effect when specified multiple times
in a single command string.

<p>
<b><a name="exam">Example usage</a></b>
<p>
<p>
To create a JAR file that contains only those files needed
by the <code>CommandCall</code> and <code>ProgramCall</code> components,
do the following:
<ol>
<li>Go to the directory where the <code>jt400.jar</code> file is located.
<li>Type:
<pre>
java utilities.AS400ToolboxJarMaker -component CommandCall,ProgramCall
</pre>
<li>Save a copy of the original <code>jt400.jar</code> for future reference.
<li>Rename <code>jt400Small.jar</code> to <code>jt400.jar</code>.
</ol>
<p>
To extract from jt400.jar only those files needed
by class <code>com.ibm.as400.access.JDSQLStatement</code>,
using the current directory as the base directory for output, do the following:
<pre>
java utilities.AS400ToolboxJarMaker -extract -s jt400.jar
     -rf com/ibm/as400/access/JDSQLStatement.class
</pre>
Any additional files could then be manually copied into appropriate locations
in the directory tree, and a customized JAR file could be generated using the
<code>jar</code> tool provided as part of the JDK.

</em>
**/

// Design notes
/*
Assumptions:

This tool will be used only by programmers
and administrators for whom English messages are acceptable.
Hence, no translated MRI is provided with this tool.

This tool will be used on JDK 1.1 or later.
When we move to JDK 1.2, the implementation of this tool can take
advantage of the utilities in the new java.util.jar package.

The manifest will be altered based on the list of functions the user specifies.

We need to generate and put our own Javadoc for this tool.  The build process does
not run Javadoc twice because the 'extra' output files (index, table of contents, ...)
would get overlayed.  It is easier to run javadoc locally then just put the output file.
(As an alternative in this release, we could ask the builders if they could generate
this javadoc at the same time as our access and vaccess stuff.)

We are going to include only run-time gifs.  Compile time gifs needed by visual builders
will not be put in the JAR unless explicitly specified.
*/

// * On-going TBDs:
// * Implementation:   Add new components as they are added to Toolbox.
//
// * Implementation:   Add new language MRI suffixes as they are supported.
//
// * Implementation:  When we move to JDK 1.2, 
//                    we can take advantage of the java.util.jar support.
//

public class AS400ToolboxJarMaker extends JarMaker
{
  private static final String copyright = "Copyright (C) 1997-2001 International Business Machines Corporation and others.";


  // Constants.

  // Component names that can be specified on the -component option.
  static final String[] VALID_COMPONENTS = {
    "AS400", "CommandCall", "DataArea", "DataDescription", "DataQueue",
    "DigitalCertificate", "FTP", "IntegratedFileSystem", "JAAS",
    "JavaApplicationCall",
    "JDBC", "Job", "Message", "NumericDataTypes",
    "Print", "ProgramCall", "RecordLevelAccess", "SecureAS400",
    "ServiceProgramCall", "SystemStatus", "SystemValue",
    "Trace", "User", "UserSpace",
    "AS400Visual", "CommandCallVisual", "DataQueueVisual",
    "IntegratedFileSystemVisual", "JavaApplicationCallVisual",
    "JDBCVisual", "JobVisual",
    "MessageVisual", "PrintVisual", "ProgramCallVisual",
    "RecordLevelAccessVisual", "UserVisual",
    "ConnectionPool",  // @A2a
    "NetServer"        // @A3a
    };
  // Note: The following list must be kept in sync with VALID_COMPONENTS.

  /** Constant for specifying the <b>AS400</b> component. **/
  public static final Integer AS400 = new Integer (0);
  /** Constant for specifying the <b>Command Call</b> component. **/
  public static final Integer COMMAND_CALL = new Integer (1);
  /** Constant for specifying the <b>Data Area</b> component. **/
  public static final Integer DATA_AREA = new Integer (2);
  /** Constant for specifying the <b>Data Description</b> component. **/
  public static final Integer DATA_DESCRIPTION = new Integer (3);
  /** Constant for specifying the <b>Data Queue</b> component. **/
  public static final Integer DATA_QUEUE = new Integer (4);
  /** Constant for specifying the <b>Digital Certificate</b> component. **/
  public static final Integer DIGITAL_CERTIFICATE = new Integer (5);
  /** Constant for specifying the <b>FTP</b> component. **/
  public static final Integer FTP = new Integer (6);
  /** Constant for specifying the <b>Integrated File System</b> component. **/
  public static final Integer INTEGRATED_FILE_SYSTEM = new Integer (7);
  /** Constant for specifying the <b>JAAS</b> component. **/
  public static final Integer JAAS = new Integer (8);
  /** Constant for specifying the <b>Java Application Call</b> component. **/
  public static final Integer JAVA_APPLICATION_CALL = new Integer (9);
  /** Constant for specifying the <b>JDBC</b> component. **/
  public static final Integer JDBC = new Integer (10);
  /** Constant for specifying the <b>Job</b> component. **/
  public static final Integer JOB = new Integer (11);
  /** Constant for specifying the <b>Message Queue</b> component. **/
  public static final Integer MESSAGE = new Integer (12);
  /** Constant for specifying the <b>Numeric Data Types</b> component. **/
  public static final Integer NUMERIC_DATA_TYPES = new Integer (13);
  /** Constant for specifying the <b>Network Print</b> component. **/
  public static final Integer PRINT = new Integer (14);
  /** Constant for specifying the <b>Program Call</b> component. **/
  public static final Integer PROGRAM_CALL = new Integer (15);
  /** Constant for specifying the <b>Record Level Access</b> component. **/
  public static final Integer RECORD_LEVEL_ACCESS = new Integer (16);
  /** Constant for specifying the <b>Secure AS400</b> component.
   This component performs SSL (Secure Sockets Layer) processing. **/
  public static final Integer SECURE_AS400 = new Integer (17);
  /** Constant for specifying the <b>Service Program Call</b> component. **/
  public static final Integer SERVICE_PROGRAM_CALL = new Integer (18);
  /** Constant for specifying the <b>System Status</b> component. **/
  public static final Integer SYSTEM_STATUS = new Integer (19);
  /** Constant for specifying the <b>System Value</b> component. **/
  public static final Integer SYSTEM_VALUE = new Integer (20);
  /** Constant for specifying the <b>Trace</b> component. **/
  public static final Integer TRACE = new Integer (21);
  /** Constant for specifying the <b>User</b> component. **/
  public static final Integer USER = new Integer (22);
  /** Constant for specifying the <b>User Space</b> component. **/
  public static final Integer USER_SPACE = new Integer (23);
  /** Constant for specifying the <b>Visual AS400</b> component. **/
  public static final Integer AS400_VISUAL = new Integer (24);
  /** Constant for specifying the <b>Visual Command Call</b> component. **/
  public static final Integer COMMAND_CALL_VISUAL = new Integer (25);
  /** Constant for specifying the <b>Visual Data Queue</b> component. **/
  public static final Integer DATA_QUEUE_VISUAL = new Integer (26);
  /** Constant for specifying the <b>Visual Integrated File System </b> component. **/
  public static final Integer INTEGRATED_FILE_SYSTEM_VISUAL = new Integer (27);
  /** Constant for specifying the <b>Visual Java Application Call</b> component. **/
  public static final Integer JAVA_APPLICATION_CALL_VISUAL = new Integer (28);
  /** Constant for specifying the <b>Visual JDBC</b> component. **/
  public static final Integer JDBC_VISUAL = new Integer (29);  // and Visual SQL
  /** Constant for specifying the <b>Visual Job</b> component. **/
  public static final Integer JOB_VISUAL = new Integer (30);
  /** Constant for specifying the <b>Visual Message Queue</b> component. **/
  public static final Integer MESSAGE_VISUAL = new Integer (31);
  /** Constant for specifying the <b>Visual Network Print</b> component. **/
  public static final Integer PRINT_VISUAL = new Integer (32);
  /** Constant for specifying the <b>Visual Program Call</b> component. **/
  public static final Integer PROGRAM_CALL_VISUAL = new Integer (33);
  /** Constant for specifying the <b>Visual Record Level Access</b> component. **/
  public static final Integer RECORD_LEVEL_ACCESS_VISUAL = new Integer (34);
  /** Constant for specifying the <b>Visual User</b> component. **/
  public static final Integer USER_VISUAL = new Integer (35);
  /** Constant for specifying the <b>Connection Pool</b> component. **/
  public static final Integer CONNECTION_POOL = new Integer (36);  // @A2a
  /** Constant for specifying the <b>NetServer</b> component. **/
  public static final Integer NETSERVER = new Integer (37);  // @A3a

  private static final Integer NO_SUCH_COMPONENT = new Integer (-1);



  private static final String CAIA = "com/ibm/as400/access/";  // for convenience
  private static final String CAIV = "com/ibm/as400/vaccess/";
  private static final String CAISA = "com/ibm/as400/security/auth/";

  private static final String COPYRIGHT_ENTRY_NAME = CAIA + "copyright.txt";

  static final String DEFAULT_SOURCE_JAR_NAME = "jt400.jar";

  // The components specified by the user (Integer's).
  private Vector components_ = new Vector ();  // Never null.

  // The languages (locales) specified by the user (String's).
  private Vector languages_ = new Vector ();  // Never null.

  // Directory where language files (if languages are specified).
  // are to be searched for.  Default is the current directory.
  private File languageDirectory_ = new File (System.getProperty ("user.dir"));

  // The CCSIDs specified by the user (Integer's).
  private Vector ccsids_= new Vector ();  // Never null.
  // The excluded CCSIDs specified by the user (Integer's).
  private Vector ccsidsExcluded_= new Vector ();  // Never null.

  // Whether proxy files are to excluded.
  private boolean noProxy_;  // If true, then exclude proxy files.

  // Invocation arguments.  This is used only when AS400ToolboxJarMaker
  // is invoked from the command line.
  private Arguments arguments_ = new Arguments ();


  /**
   Constructs an AS400ToolboxJarMaker object.
   **/
  public AS400ToolboxJarMaker ()
  {
    super ("com/ibm/as400"); // Default entry-name prefix.
    File defaultSourceJar = new File (DEFAULT_SOURCE_JAR_NAME);
    setSourceJar (defaultSourceJar);
  }


  /**
   Adds MRI files to the additional files list.
   <br>Note: This augments any previously specified language files.

   @param baseDirectory The base directory for the language files.
   @param neededJarEntries The current list of required files
   and their dependencies.
   The list should contain only <code>String</code> objects.
   @param jarMap A map of the source JAR or ZIP file.
   **/
  private void addLanguageFiles (File baseDirectory,
                                 Vector neededJarEntries, JarMap jarMap)
  {
    // Note: If any of the arguments is null, it is due to an
    // internal programming error.
    if (baseDirectory == null)
      throw new NullPointerException ("baseDirectory");
    if (neededJarEntries == null)
      throw new NullPointerException ("neededJarEntries");
    if (jarMap == null)
      throw new NullPointerException ("jarMap");

    // Get a list of the MRI files in the source jar.
    // The list should look something like:
    //    com/ibm/as400/access/MRI.properties,
    //    com/ibm/as400/access/JDMRI.properties, ...
    // (Note: Beginning with V4R4, MRI's are "*.class"
    //        rather than "*.properties".  This design handles that.)

    // Make a list of the MRI files in the "needed JAR entries" list.
    Vector neededLanguageEntries = new Vector ();  // String's
    Enumeration e = neededJarEntries.elements ();
    while (e.hasMoreElements ())
    {
      String entryName = (String)e.nextElement ();
      // See if the filename has "MRI" in it.
      if (entryName.lastIndexOf ("MRI") > entryName.lastIndexOf ('/'))
        neededLanguageEntries.addElement (entryName);
    }

    if (languages_.size () != 0)
    {
      // Add the language-specific *MRI_xx_XX.[properties|class] files to
      // the "additional files" list.
      Vector filesToAdd = new Vector ();
      Enumeration e1 = languages_.elements ();
      while (e1.hasMoreElements ())
      {
        String languageSuffix = (String)e1.nextElement ();
        Enumeration e2 = neededLanguageEntries.elements ();
        while (e2.hasMoreElements ())
        {
          String entryName = (String)e2.nextElement ();
          // Insert the language ID after the "MRI".
          String newEntryName = addMriSuffix (entryName, languageSuffix);
          String filePath = generateFilePath (languageDirectory_, newEntryName);
          if (DEBUG) System.out.println ("Debug: Adding MRI file " + filePath);
          filesToAdd.addElement (new File (filePath));
        }
      }

      // Add the list of language files to the additional files list.
      setAdditionalFiles (filesToAdd, baseDirectory);
    }
    else // User specified no specific languages.
    {
      // Go through the list of referenced MRI files,
      // and mark as "needed" the corresponding _en and _en_US
      // entries if they exist.
      Enumeration e1 = neededLanguageEntries.elements ();
      while (e1.hasMoreElements ())
      {
        String entryName = (String)e1.nextElement ();
        String entryName_en = addMriSuffix (entryName, "en");
        String entryName_en_US = addMriSuffix (entryName, "en_US");
        if (DEBUG) {
          System.out.println ("Debug: entryName_en    = " + entryName_en);
          System.out.println ("       entryName_en_US = " + entryName_en_US);
        }
        if (jarMap.contains (entryName_en) &&
            !neededJarEntries.contains (entryName_en))
          neededJarEntries.addElement (entryName_en);
        if (jarMap.contains (entryName_en_US) &&
            !neededJarEntries.contains (entryName_en_US))
          neededJarEntries.addElement (entryName_en_US);
      }
    }
  }

  /**
   Constructs a new ZIP entry name by inserting the specified
   language suffix into the specified entry name.
   @param entryName The ZIP entry name into which to insert the suffix.
   @param languageSuffix The language suffix to insert.  For example, "en_US".
   @return The constructed entry name, with suffix inserted.
   **/
  private static String addMriSuffix (String entryName, String languageSuffix)
  {
    // Insert the language ID into the entry name after the "MRI".
    int insertionPosition = entryName.lastIndexOf ("MRI") + 3;
    StringBuffer buf = new StringBuffer (entryName);
    buf.insert (insertionPosition, "_"+languageSuffix);
    return buf.toString ();
  }


  // @A3a
  /**
   Adds any needed PCML files to the additional files list.
   <br>Note: This augments any previously specified PCML files.

   @param neededJarEntries The current list of required files
   and their dependencies.
   The list should contain only <code>String</code> objects.
   @param jarMap A map of the source JAR or ZIP file.
   **/
  private static void addPcmlFiles (Vector neededJarEntries, JarMap jarMap)
  {
    // Note: If any of the arguments is null, it is due to an
    // internal programming error.
    if (neededJarEntries == null)
      throw new NullPointerException ("neededJarEntries");
    if (jarMap == null)
      throw new NullPointerException ("jarMap");

    // Get a list of the PCML files in the source jar.
    // The list should look something like:
    //    com/ibm/as400/resource/RJob.pcml,
    //    com/ibm/as400/resource/RJob.pcml.ser, ...
    // That is, look for any files with names ending ".pcml" or ".pcml.ser".

    // Make a list of the PCML files in the source jar file.
    Enumeration e = jarMap.elements ();
    Vector neededPcmlEntries = new Vector();
    while (e.hasMoreElements ())
    {
      String entryName = (String)e.nextElement ();
      // See if the filename ends with ".pcml" or ".pcml.ser".
      if (entryName.endsWith (".pcml") || entryName.endsWith (".pcml.ser"))
        neededPcmlEntries.addElement (entryName);
    }

    // Go through the list of PCML files contained in the source jar file,
    // and mark as "needed" any that have a corresponding class file in the
    // "needed files" list.
    Enumeration e1 = neededPcmlEntries.elements ();
    while (e1.hasMoreElements ())
    {
      String pcmlEntryName = (String)e1.nextElement ();
      // Get the associated class file entry name.
      String classEntryName = getClassEntryForPcml (pcmlEntryName);
      if (neededJarEntries.contains (classEntryName) &&
          !neededJarEntries.contains (pcmlEntryName))
        neededJarEntries.addElement (pcmlEntryName);
    }
  }


  /**
   Adds or removes ZIP entry names from the "required files" list,
   prior to initial generation of the dependencies list.
   This method is provided so that subclasses of JarMaker can override it.
   <br><em>This method is meant to be called by the JarMaker class only.</em>

   @param neededJarEntries An unsorted list of names of ZIP entries
   that should be included in the output.
   @param jarMap A map of the source JAR or ZIP file.
   @return The modified list of ZIP entry names
   (must never be <code>null</code>.
   This should be a Vector of Strings.
   @exception IOException If an error occurs when reading the source file.
   **/
  Vector adjustDependencies1 (Vector neededJarEntries, JarMap jarMap)
    throws IOException
  {
    // Add selected ConvTableXXX files, per -ccsid list.
    if (ccsids_.size () == 0)
    { // User specified no particular ccsids.
      // We will add *all* of the ccsids (if appropriate) in adjustDependencies2().
    }
    else // User specified one or more particular ccsids.
    {
      // If the IFS component was specified, be sure to include
      // the "old Unicode" ccsid.  @A0a
      if (components_.contains (INTEGRATED_FILE_SYSTEM))
        addElement(ccsids_, new Integer(61952));

      // In all cases, be sure to include the "new Unicode" ccsid.  @A2a
      addElement(ccsids_, new Integer(13488));

      // Add the ConvTableXXX's for the selected CCSIDs.
      Enumeration e3 = ccsids_.elements ();
      while (e3.hasMoreElements ())
      {
        Integer ccsid = (Integer)e3.nextElement ();
        String entry = CAIA + "ConvTable" + ccsid.toString () +
          CLASS_SUFFIX;
        if (!neededJarEntries.contains (entry))
        {
          if (jarMap.contains (entry))
          {
            neededJarEntries.addElement (entry);
          }
          else
            System.err.println ("Warning: No entry in source file for " +
                                "CCSID " + ccsid.toString () + ".");
        }
      }

    }

    // See if user gave the OK to selectively limit dependency expansion.  @A4a
    if (excludeSomeDependencies_)
    {
      // Note: As of V5R2, AS400ThreadedServer references DBReplyRequestedDS.
      // We can't just exclude DBReplyRequestedDS, nor can we exclude its
      // direct dependents (DBBaseReplyDS and DBDSPool), but we *can* exclude
      // the files that *those* classes depend on.                      @A4a

      // If the 'access' package isn't on the packages list,
      // and neither JDBC nor Visual JDBC is on the components list,
      // and DBReplyRequestedDS isn't on the required files list,
      // then exclude a couple of JDBC files.                           @A4a
      if (!(getPackages().contains ("com.ibm.as400.access")) &&
          !(components_.contains (JDBC)) &&
          !(components_.contains (JDBC_VISUAL)))
      {
        if (!getRequiredFiles().contains("com/ibm/as400/access/DBBaseReplyDS.class"))
        {
          addElement(dependenciesToExclude_, "com/ibm/as400/access/DBBaseReplyDS.class");
          if (verbose_ || DEBUG) {
            System.out.println("Excluding dependency: " + "com/ibm/as400/access/DBBaseReplyDS.class");
          }

          if (!getRequiredFiles().contains("com/ibm/as400/access/DBDSPool.class"))
          {
            addElement(dependenciesToExclude_, "com/ibm/as400/access/DBDSPool.class");
            if (verbose_ || DEBUG) {
              System.out.println("Excluding dependency: " + "com/ibm/as400/access/DBDSPool.class");
            }
          }
        }
      }

      // Note: In V5R1, we added a getJob() method to CommandCall and ProgramCall,
      // that returns an RJob object.  Unfortunately this introduced a new
      // dependency on the 'resource' package.
      // In V5R2 we added method getServerJob() that returns a Job object,
      // and we intend to deprecate getJob().                           @A4a

      // TBD: If we're dealing with a V5R1 jt400.jar file, don't exclude RJob.
      // TBD: Deprecate the getJob() method of CommandCall and ProgramCall.  @A4a

      // If the 'resource' package isn't on the packages list,
      // and neither RJob nor JobLog is on the required files list,
      // and neither Job nor Visual Job is on the components list,
      // then add RJob to the list of files to exclude.                 @A4a
      if (!(getPackages().contains ("com.ibm.as400.resource")) &&
          !(getRequiredFiles().contains("com/ibm/as400/resource/RJob.class")) &&
          !(getRequiredFiles().contains("com/ibm/as400/access/JobLog.class")) &&
          !(components_.contains (JOB)) &&
          !(components_.contains (JOB_VISUAL)))
      {
        addElement(dependenciesToExclude_, "com/ibm/as400/resource/RJob.class");
        if (verbose_ || DEBUG) {
          System.out.println("Excluding dependency: " + "com/ibm/as400/resource/RJob.class");
        }
      }
    }

    return neededJarEntries;
  }


  /**
   Adds or removes ZIP entry names from the dependencies list,
   prior to final presentation of the dependencies list.
   This method is provided so that subclasses of JarMaker can override it.
   <br><em>This method is meant to be called by the JarMaker class only.</em>

   @param neededJarEntries An unsorted list of names of ZIP entries
   that should be included in the output.
   @param jarMap A map of the source JAR or ZIP file.
   @return The modified list of ZIP entry names
   (must never be <code>null</code>.
   This should be a Vector of Strings.
   @exception IOException If an error occurs when reading the source file.
   **/
  Vector adjustDependencies2 (Vector neededJarEntries, JarMap jarMap)
    throws IOException
  {

    // If the source jar file contains ConvTableJavaMap.class, it is Mod4 or later.
    // Otherwise it is pre-Mod4.
    boolean jarIsPreMod4;
    String entry1 = CAIA + "ConvTableJavaMap" + CLASS_SUFFIX;
    if (jarMap.contains(entry1))
      jarIsPreMod4 = false;
    else
      jarIsPreMod4 = true;

    // See if ConvTable.class was referenced.  If so, make sure we end up with
    // exactly the ConvTableXXX entries that we need, no more and no less.
    if (neededJarEntries.contains (new String(CAIA + "ConvTable" + CLASS_SUFFIX)))
    {  // Some or all of the ConvTableXXX files are needed, so include the right ones.

      if (ccsids_.size () == 0)
      { // User specified no particular ccsids, so include them all.

        if (jarIsPreMod4)
        {  // Nothing to do, all the ConvTableXXX files are all referenced in ConvTable.java.
        }
        else
        {  // The ConvTableXXX files need to be added explicitly.
          Vector entriesToAdd = new Vector ();
          Enumeration e = jarMap.elements ();
          while (e.hasMoreElements ())
          {
            String entry = (String)e.nextElement ();
            // We are looking for entries like "..../ConvTableXXX.yyyy",
            // where xxx is an integer greater than 0.
            String className = entry.substring (1 + entry.lastIndexOf ('/'));
            if (className.startsWith ("ConvTable") &&
                Character.isDigit (className.charAt (9))) // char after "ConvTable"
              entriesToAdd.addElement (entry);
          }

          // Determine the dependencies for the ConvTableXXX's.
          Enumeration enum = entriesToAdd.elements();
          Vector unanalyzedEntries = jarMap.getEntryNames();
          Vector referencedJarEntries = new Vector();
          while (enum.hasMoreElements())
          {
            String entryName = (String)enum.nextElement ();
            if (unanalyzedEntries.contains (entryName))
            {
              unanalyzedEntries.removeElement (entryName);
              analyzeJarEntry (entryName, unanalyzedEntries,
                               referencedJarEntries, jarMap);
              addElement (referencedJarEntries, entryName);
            }
          }
          copyVectorToFrom (neededJarEntries, referencedJarEntries, CHECK_DUPS); // @A3c
        }
      }  // ... no particular ccsids were specified.

      else // User specified one or more particular ccsids.
      {

        if (!jarIsPreMod4)
        {
          // We are dealing with a Mod4 or later Toolbox jar file.
          // No special action is required.
        }
        else
          // We are dealing with a pre-Mod4 Toolbox jar file.
          // Weed out any unneeded ConvTableXXX entries that get dragged in
          // (because their names are all referenced in ConvTable.java).
        {
          if (ccsids_.size () != 0)  // Did the user specify any particular CCSIDs.
          {
            // First clear all ConvTableXXX entries from the dependencies list.
            Vector entriesToRemove = new Vector ();
            Enumeration e = neededJarEntries.elements ();
            while (e.hasMoreElements ())
            {
              String entry = (String)e.nextElement ();
              // We are looking for entries like "..../ConvTableXXX.yyyy",
              // where xxx is an integer greater than 0.
              String className = entry.substring (1 + entry.lastIndexOf ('/'));
              if (className.startsWith ("ConvTable") &&
                  Character.isDigit (className.charAt (9))) // char after "ConvTable"
                entriesToRemove.addElement (entry);
            }
            Enumeration e2 = entriesToRemove.elements ();
            while (e2.hasMoreElements ())
            {
              neededJarEntries.removeElement ((String)e2.nextElement());
            }

            // If the IFS component was specified, be sure to include
            // the "old Unicode" ccsid.  @A0a
            if (components_.contains (INTEGRATED_FILE_SYSTEM))
              addElement(ccsids_, new Integer(61952));

            // In all cases, be sure to include the "new Unicode" ccsid.  @A2a
            addElement(ccsids_, new Integer(13488));

            // Now add back in the ConvTableXXX's for the selected CCSIDs.
            Enumeration e3 = ccsids_.elements ();
            while (e3.hasMoreElements ())
            {
              Integer ccsid = (Integer)e3.nextElement ();
              String entry = CAIA + "ConvTable" + ccsid.toString () +
                CLASS_SUFFIX;
              if (!neededJarEntries.contains (entry))
              {
                if (jarMap.contains (entry))
                {
                  neededJarEntries.addElement (entry);
                }
                else
                  System.err.println ("Warning: No entry in source file for " +
                                      "CCSID " + ccsid.toString () + ".");
              }
            }
          }
        }
      }
    }  // ... include the right ConvTableXXX files, per the -ccsid list.

    // Remove selected ConvTableXXX files, per -ccsidExcluded list.
    if (ccsidsExcluded_.size () != 0)
    {
      Enumeration e = ccsidsExcluded_.elements ();
      while (e.hasMoreElements ())
      {
        Integer ccsid = (Integer)e.nextElement ();
        String entry = CAIA + "ConvTable" + ccsid.toString () +
          CLASS_SUFFIX;
        neededJarEntries.removeElement (entry);
        if (!jarMap.contains (entry))
          System.err.println ("Warning: No entry in source file for " +
                              "excluded CCSID " + ccsid.toString () + ".");
      }
    }


    // Load the entry names associated with any required packages.
    // Note that these files will not be explicitly analyzed.
    addPackageFiles(neededJarEntries, jarMap, getPackages());    // @A3a

    // Add any needed MRI files to the "additional files" list.
    // Note: Regardless of language selection, don't remove the base MRI files.
    // That way, we always have a last-ditch default for messages (English),
    // no matter what locale the JAR file is used in.
    addLanguageFiles (languageDirectory_, neededJarEntries, jarMap);

    // Add any needed PCML files to the "additional files" list.
    addPcmlFiles (neededJarEntries, jarMap);                        // @A3a

    // If -noproxy option was specified, remove proxy files.
    if (noProxy_)
    {
      Vector entriesToRemove = new Vector ();
      Enumeration e = neededJarEntries.elements ();
      while (e.hasMoreElements ())
      {
        String entry = (String)e.nextElement ();
        // We are looking for entries like:
        //    "..../###Proxy.class",
        //    "..../###ProxyImpl.class",
        //    "..../Proxy###.class",
        //    "..../Px###.class",
        String className = entry.substring (1 + entry.lastIndexOf ('/'));
        if (className.endsWith (CLASS_SUFFIX))
        {
          className = className.substring(0,className.lastIndexOf(CLASS_SUFFIX));
          if ((className.endsWith ("Proxy")) ||
              (className.endsWith ("ProxyImpl")) ||
              (className.startsWith ("Proxy")) ||
              (className.startsWith ("Px")) )
          {
            entriesToRemove.addElement (entry);
            if (verbose_ || DEBUG) {
              System.out.println("Excluding proxy class: " + className);
            }
          }
        }
      }
      Enumeration e2 = entriesToRemove.elements ();
      while (e2.hasMoreElements ())
        neededJarEntries.removeElement ((String)e2.nextElement ());
    }

    // Make sure that the copyright gets included.
    if (jarMap.contains (COPYRIGHT_ENTRY_NAME))
    {
      addElement (neededJarEntries, COPYRIGHT_ENTRY_NAME);
    }

    return neededJarEntries;
  }


  /**
   Returns the base dependencies for a component.

   @param comp The component ID.
   @return The names of the ZIP entries that comprise the "base dependency list"
           for the specified component.  (String's)
   **/
  private static Vector getBaseDependenciesForComponent (Integer comp,
                                                 boolean includeBeans)
  {
    // Implementation note:  These are the base dependency lists for the
    // various Toolbox components as of mod1 (v3r2m1).  The lists will need
    // to be updated in future releases, as components are added and
    // as component designs evolve.

    Vector deps = new Vector (); // base ZIP entries for component

    if (comp.equals (AS400))
    {
      deps.addElement   (CAIA+"AS400.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"AS400BeanInfo.class");
      }
    }
    else if (comp.equals (COMMAND_CALL))
    {
      deps.addElement   (CAIA+"CommandCall.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"CommandCallBeanInfo.class");
      }
    }
    else if (comp.equals (CONNECTION_POOL))  // @A2a
    {
      deps.addElement   (CAIA+"AS400ConnectionPool.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"AS400ConnectionPoolBeanInfo.class");
        deps.addElement (CAIA+"ConnectionPoolBeanInfo.class");
      }
    }
    else if (comp.equals (DATA_AREA))
    {
      deps.addElement   (CAIA+"CharacterDataArea.class");
      deps.addElement   (CAIA+"DecimalDataArea.class");
      deps.addElement   (CAIA+"LocalDataArea.class");
      deps.addElement   (CAIA+"LogicalDataArea.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"CharacterDataAreaBeanInfo.class");
        deps.addElement (CAIA+"DecimalDataAreaBeanInfo.class");
        deps.addElement (CAIA+"LocalDataAreaBeanInfo.class");
        deps.addElement (CAIA+"LogicalDataAreaBeanInfo.class");
      }
    }
    else if (comp.equals (DATA_DESCRIPTION))
    {
      // Field description classes:
      deps.addElement   (CAIA+"ArrayFieldDescription.class");
      deps.addElement   (CAIA+"BinaryFieldDescription.class");
      deps.addElement   (CAIA+"CharacterFieldDescription.class");
      deps.addElement   (CAIA+"DateFieldDescription.class");
      deps.addElement   (CAIA+"DBCSEitherFieldDescription.class");
      deps.addElement   (CAIA+"DBCSGraphicFieldDescription.class");
      deps.addElement   (CAIA+"DBCSOnlyFieldDescription.class");
      deps.addElement   (CAIA+"DBCSOpenFieldDescription.class");
      deps.addElement   (CAIA+"FloatFieldDescription.class");
      deps.addElement   (CAIA+"HexFieldDescription.class");
      deps.addElement   (CAIA+"PackedDecimalFieldDescription.class");
      deps.addElement   (CAIA+"TimeFieldDescription.class");
      deps.addElement   (CAIA+"TimestampFieldDescription.class");
      deps.addElement   (CAIA+"VariableLengthFieldDescription.class");
      deps.addElement   (CAIA+"ZonedDecimalFieldDescription.class");

      deps.addElement   (CAIA+"AS400Array.class");
      deps.addElement   (CAIA+"AS400Bin2.class");
      deps.addElement   (CAIA+"AS400Bin4.class");
      deps.addElement   (CAIA+"AS400ByteArray.class");
      deps.addElement   (CAIA+"AS400Float4.class");
      deps.addElement   (CAIA+"AS400Float8.class");
      deps.addElement   (CAIA+"AS400PackedDecimal.class");
      deps.addElement   (CAIA+"AS400Structure.class");
      deps.addElement   (CAIA+"AS400Text.class");
      deps.addElement   (CAIA+"AS400UnsignedBin2.class");
      deps.addElement   (CAIA+"AS400UnsignedBin4.class");
      deps.addElement   (CAIA+"AS400ZonedDecimal.class");
      deps.addElement   (CAIA+"Record.class"); // references RecordFormat
      if (includeBeans)
      {
        deps.addElement (CAIA+"AS400ArrayBeanInfo.class");
        deps.addElement (CAIA+"AS400StructureBeanInfo.class");
        deps.addElement (CAIA+"RecordBeanInfo.class");
        deps.addElement (CAIA+"RecordFormatBeanInfo.class");
      }
    }
    else if (comp.equals (DATA_QUEUE))
    {
      deps.addElement   (CAIA+"DataQueue.class");
      deps.addElement   (CAIA+"KeyedDataQueue.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"BaseDataQueueBeanInfo.class");
        deps.addElement (CAIA+"DataQueueAttributesBeanInfo.class");
        deps.addElement (CAIA+"DataQueueBeanInfo.class");
        deps.addElement (CAIA+"KeyedDataQueueBeanInfo.class");
      }
    }
    else if (comp.equals (DIGITAL_CERTIFICATE))
    {
      deps.addElement   (CAIA+"AS400Certificate.class");
      deps.addElement   (CAIA+"AS400CertificateAttribute.class");
      deps.addElement   (CAIA+"AS400CertificateUserProfileUtil.class");
      deps.addElement   (CAIA+"AS400CertificateVldlUtil.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"AS400CertificateUserProfileUtilBeanInfo.class");
        deps.addElement (CAIA+"AS400CertificateUtilBeanInfo.class");
        deps.addElement (CAIA+"AS400CertificateVldlUtilBeanInfo.class");
      }
    }
    else if (comp.equals (FTP))
    {
      deps.addElement   (CAIA+"AS400FTP.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"AS400FTPBeanInfo.class");
        deps.addElement (CAIA+"FTPBeanInfo.class");
      }
    }
    else if (comp.equals (INTEGRATED_FILE_SYSTEM))
    {
      deps.addElement   (CAIA+"IFSFile.class");
      deps.addElement   (CAIA+"IFSRandomAccessFile.class");
      deps.addElement   (CAIA+"IFSTextFileInputStream.class");
      deps.addElement   (CAIA+"IFSTextFileOutputStream.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"IFSFileBeanInfo.class");
        deps.addElement (CAIA+"IFSRandomAccessFileBeanInfo.class");
        deps.addElement (CAIA+"IFSTextFileInputStreamBeanInfo.class");
        deps.addElement (CAIA+"IFSTextFileOutputStreamBeanInfo.class");
      }
    }
    else if (comp.equals (JAAS))
    {
      deps.addElement   (CAISA+"ProfileHandleCredential.class");
      deps.addElement   (CAISA+"ProfileTokenCredential.class");
      deps.addElement   (CAISA+"UserProfilePrincipal.class");
      if (includeBeans)
      {
        deps.addElement (CAISA+"ProfileHandleCredentialBeanInfo.class");
        deps.addElement (CAISA+"ProfileTokenCredentialBeanInfo.class");
        deps.addElement (CAISA+"UserProfilePrincipalBeanInfo.class");
      }
    }
    else if (comp.equals (JAVA_APPLICATION_CALL))
    {
      deps.addElement   (CAIA+"JavaApplicationCall.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"JavaApplicationCallBeanInfo.class");
      }
    }
    else if (comp.equals (JDBC))
    {
      deps.addElement   (CAIA+"AS400JDBCDriver.class");
      deps.addElement   (CAIA+"AS400JDBCRowSet.class");          // @A2a
      deps.addElement   (CAIA+"AS400JDBCXAConnection.class");    // @A2a
      deps.addElement   (CAIA+"AS400JDBCConnectionPool.class");  // @A2a
      if (includeBeans)
      {
        deps.addElement (CAIA+"AS400JDBCRowSetBeanInfo.class");          // @A2a
        deps.addElement (CAIA+"AS400JDBCDataSourceBeanInfo.class");      // @A2a
        deps.addElement (CAIA+"AS400JDBCXADataSourceBeanInfo.class");    // @A2a
        deps.addElement (CAIA+"AS400JDBCConnectionPoolBeanInfo.class");  // @A2a
        deps.addElement (CAIA+"AS400JDBCConnectionPoolDataSourceBeanInfo.class"); // @A2a
        deps.addElement (CAIA+"ConnectionPoolBeanInfo.class");           // @A2a
      }
    }
    else if (comp.equals (JOB))
    {
      deps.addElement   (CAIA+"JobList.class");
      deps.addElement   (CAIA+"JobLog.class");
      if (includeBeans)
      {  // No beans for this component.
      }
    }
    else if (comp.equals (MESSAGE))
    {
      deps.addElement   (CAIA+"MessageQueue.class");
      if (includeBeans)
      {  // No beans for this component.
      }
    }
    else if (comp.equals (NETSERVER))  // @A3a
    {
      deps.addElement   (CAIA+"NetServer.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"NetServerBeanInfo.class");
        deps.addElement (CAIA+"NetServerFileShareBeanInfo.class");
        deps.addElement (CAIA+"NetServerPrintShareBeanInfo.class");
      }
    }
    else if (comp.equals (NUMERIC_DATA_TYPES))
    {  // All the DataType classes except for AS400Text.
      deps.addElement   (CAIA+"AS400Array.class");
      deps.addElement   (CAIA+"AS400Bin2.class");
      deps.addElement   (CAIA+"AS400Bin4.class");
      deps.addElement   (CAIA+"AS400ByteArray.class");
      deps.addElement   (CAIA+"AS400Float4.class");
      deps.addElement   (CAIA+"AS400Float8.class");
      deps.addElement   (CAIA+"AS400PackedDecimal.class");
      deps.addElement   (CAIA+"AS400Structure.class");
      deps.addElement   (CAIA+"AS400UnsignedBin2.class");
      deps.addElement   (CAIA+"AS400UnsignedBin4.class");
      deps.addElement   (CAIA+"AS400ZonedDecimal.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"AS400ArrayBeanInfo.class");
        deps.addElement (CAIA+"AS400StructureBeanInfo.class");
      }
    }
    else if (comp.equals (PRINT))
    {
      deps.addElement   (CAIA+"AFPResourceList.class");
      deps.addElement   (CAIA+"OutputQueueList.class");
      deps.addElement   (CAIA+"PrinterList.class");
      deps.addElement   (CAIA+"PrintObjectInputStream.class");
      deps.addElement   (CAIA+"SpooledFileList.class");
      deps.addElement   (CAIA+"SpooledFileOutputStream.class");
      deps.addElement   (CAIA+"SCS3812Writer.class");
      deps.addElement   (CAIA+"SCS5553Writer.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"AFPResourceBeanInfo.class");
        deps.addElement (CAIA+"AFPResourceListBeanInfo.class");
        deps.addElement (CAIA+"OutputQueueBeanInfo.class");
        deps.addElement (CAIA+"OutputQueueListBeanInfo.class");
        deps.addElement (CAIA+"PrintObjectBeanInfo.class");
        deps.addElement (CAIA+"PrintObjectListBeanInfo.class");
        deps.addElement (CAIA+"PrinterBeanInfo.class");
        deps.addElement (CAIA+"PrinterFileBeanInfo.class");
        deps.addElement (CAIA+"PrinterFileListBeanInfo.class");
        deps.addElement (CAIA+"PrinterListBeanInfo.class");
        deps.addElement (CAIA+"SpooledFileListBeanInfo.class");
        deps.addElement (CAIA+"WriterJobListBeanInfo.class");
      }
    }
    else if (comp.equals (PROGRAM_CALL))
    {
      deps.addElement   (CAIA+"ProgramCall.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"ProgramCallBeanInfo.class");
        deps.addElement (CAIA+"ProgramParameterBeanInfo.class");
      }
    }
    else if (comp.equals (RECORD_LEVEL_ACCESS))
    {
      deps.addElement   (CAIA+"AS400FileRecordDescription.class");
      deps.addElement   (CAIA+"KeyedFile.class");  // extends AS400File
      deps.addElement   (CAIA+"SequentialFile.class");
      deps.addElement   (CAIA+"DDMAS400MessageReply.class"); // extends DDMReplyDataStream
      deps.addElement   (CAIA+"DDMConnection.class");
      deps.addElement   (CAIA+"DDMEndUnitOfWorkReply.class");
      deps.addElement   (CAIA+"DDMObjectDataStream.class"); // extends DDMDataStream
      deps.addElement   (CAIA+"DDMRecordCache.class");
      deps.addElement   (CAIA+"DDMRequestDataStream.class"); // extends DDMDataStream
      deps.addElement   (CAIA+"DDMS38IOFB.class");
      // Field description classes:
      deps.addElement   (CAIA+"ArrayFieldDescription.class");
      deps.addElement   (CAIA+"BinaryFieldDescription.class");
      deps.addElement   (CAIA+"CharacterFieldDescription.class");
      deps.addElement   (CAIA+"DBCSEitherFieldDescription.class");
      deps.addElement   (CAIA+"DBCSGraphicFieldDescription.class");
      deps.addElement   (CAIA+"DBCSOnlyFieldDescription.class");
      deps.addElement   (CAIA+"DBCSOpenFieldDescription.class");
      deps.addElement   (CAIA+"DateFieldDescription.class");
      deps.addElement   (CAIA+"FloatFieldDescription.class");
      deps.addElement   (CAIA+"HexFieldDescription.class");
      deps.addElement   (CAIA+"PackedDecimalFieldDescription.class");
      deps.addElement   (CAIA+"TimeFieldDescription.class");
      deps.addElement   (CAIA+"TimestampFieldDescription.class");
      deps.addElement   (CAIA+"ZonedDecimalFieldDescription.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"AS400FileBeanInfo.class");
        deps.addElement (CAIA+"AS400FileRecordDescriptionBeanInfo.class");
        deps.addElement (CAIA+"KeyedFileBeanInfo.class");
        deps.addElement (CAIA+"SequentialFileBeanInfo.class");
      }
    }
    else if (comp.equals (SECURE_AS400))
    {
      deps.addElement   (CAIA+"SecureAS400.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"SecureAS400BeanInfo.class");
      }
    }
    else if (comp.equals (SERVICE_PROGRAM_CALL))
    {
      deps.addElement   (CAIA+"ServiceProgramCall.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"ServiceProgramCallBeanInfo.class");
      }
    }
    else if (comp.equals (SYSTEM_STATUS))
    {
      deps.addElement   (CAIA+"SystemStatus.class");
      deps.addElement   (CAIA+"SystemPool.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"SystemStatusBeanInfo.class");
        deps.addElement (CAIA+"SystemPoolBeanInfo.class");
      }
    }
    else if (comp.equals (SYSTEM_VALUE))
    {
      deps.addElement   (CAIA+"SystemValueList.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"SystemValueListBeanInfo.class");
        deps.addElement (CAIA+"SystemValueBeanInfo.class");
      }
    }
    else if (comp.equals (TRACE))
    {
      deps.addElement   (CAIA+"Trace.class");
    }
    else if (comp.equals (USER))
    {
      deps.addElement   (CAIA+"UserList.class");
      if (includeBeans)
      {  // No beans for this component.
      }
    }
    else if (comp.equals (USER_SPACE))
    {
      deps.addElement   (CAIA+"UserSpace.class");
      if (includeBeans)
      {
        deps.addElement (CAIA+"UserSpaceBeanInfo.class");
      }
    }
    else if (comp.equals (AS400_VISUAL))
    {
      deps.addElement   (CAIV+"AS400ListPane.class");
      deps.addElement   (CAIV+"AS400ExplorerPane.class");
      deps.addElement   (CAIV+"ErrorDialogAdapter.class");
      if (includeBeans)
      {
        deps.addElement (CAIV+"AS400DetailsModelBeanInfo.class");
        deps.addElement (CAIV+"AS400DetailsPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400ExplorerPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400ListModelBeanInfo.class");
        deps.addElement (CAIV+"AS400ListPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400TreeModelBeanInfo.class");
        deps.addElement (CAIV+"AS400TreePaneBeanInfo.class");
        deps.addElement (CAIV+"ErrorDialogAdapterBeanInfo.class");
        deps.addElement (CAIV+"VActionAdapterBeanInfo.class");
        deps.addElement (CAIV+"VPropertiesActionBeanInfo.class");
        deps.addElement (CAIV+"WorkingCursorAdapterBeanInfo.class");
      }
    }
    else if (comp.equals (COMMAND_CALL_VISUAL))
    {
      deps.addElement   (CAIV+"CommandCallButton.class");
      deps.addElement   (CAIV+"CommandCallMenuItem.class");
      if (includeBeans)
      {
        deps.addElement (CAIV+"CommandCallButtonBeanInfo.class");
        deps.addElement (CAIV+"CommandCallMenuItemBeanInfo.class");
      }
    }
    else if (comp.equals (DATA_QUEUE_VISUAL))
    {
      deps.addElement   (CAIV+"DataQueueDocument.class");
      deps.addElement   (CAIV+"KeyedDataQueueDocument.class");
      if (includeBeans)
      {
        deps.addElement (CAIV+"DataQueueDocumentBeanInfo.class");
        deps.addElement (CAIV+"KeyedDataQueueDocumentBeanInfo.class");
      }
    }
    else if (comp.equals (INTEGRATED_FILE_SYSTEM_VISUAL))
    {
      deps.addElement   (CAIV+"IFSFileDialog.class"); // not a bean
      deps.addElement   (CAIV+"IFSTextFileDocument.class");
      deps.addElement   (CAIV+"VIFSDirectory.class");
      deps.addElement   (CAIV+"AS400ExplorerPane.class");
      deps.addElement   (CAIV+"AS400ListPane.class");
      if (includeBeans)
      {
        deps.addElement (CAIV+"IFSTextFileDocumentBeanInfo.class");
        deps.addElement (CAIV+"VIFSDirectoryBeanInfo.class");
        deps.addElement (CAIV+"AS400DetailsModelBeanInfo.class");
        deps.addElement (CAIV+"AS400DetailsPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400ExplorerPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400ListModelBeanInfo.class");
        deps.addElement (CAIV+"AS400ListPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400TreeModelBeanInfo.class");
        deps.addElement (CAIV+"AS400TreePaneBeanInfo.class");
      }
    }
    else if (comp.equals (JAVA_APPLICATION_CALL_VISUAL))
    {
      deps.addElement   (CAIV+"VJavaApplicationCall.class");
      if (includeBeans)
      {
        deps.addElement (CAIV+"VJavaApplicationCallBeanInfo.class");
      }
    }
    else if (comp.equals (JDBC_VISUAL))
    {
      deps.addElement   (CAIV+"SQLResultSetFormPane.class");
      deps.addElement   (CAIV+"SQLResultSetTablePane.class");
      deps.addElement   (CAIV+"SQLStatementButton.class");
      deps.addElement   (CAIV+"SQLStatementMenuItem.class");
      deps.addElement   (CAIV+"SQLStatementDocument.class");
      deps.addElement   (CAIV+"SQLQueryBuilderPane.class");
      if (includeBeans)
      {
        deps.addElement (CAIV+"SQLConnectionBeanInfo.class");
        deps.addElement (CAIV+"SQLQueryBuilderPaneBeanInfo.class");
        deps.addElement (CAIV+"SQLResultSetFormPaneBeanInfo.class");
        deps.addElement (CAIV+"SQLResultSetTableModelBeanInfo.class");
        deps.addElement (CAIV+"SQLResultSetTablePaneBeanInfo.class");
        deps.addElement (CAIV+"SQLStatementButtonBeanInfo.class");
        deps.addElement (CAIV+"SQLStatementDocumentBeanInfo.class");
        deps.addElement (CAIV+"SQLStatementMenuItemBeanInfo.class");
      }
    }
    else if (comp.equals (JOB_VISUAL))
    {
      deps.addElement   (CAIV+"VJobList.class");
      deps.addElement   (CAIV+"AS400ExplorerPane.class");
      deps.addElement   (CAIV+"AS400ListPane.class");
      if (includeBeans)
      {
        deps.addElement (CAIV+"VJobBeanInfo.class");
        deps.addElement (CAIV+"VJobListBeanInfo.class");
        deps.addElement (CAIV+"AS400DetailsModelBeanInfo.class");
        deps.addElement (CAIV+"AS400DetailsPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400ExplorerPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400ListModelBeanInfo.class");
        deps.addElement (CAIV+"AS400ListPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400TreeModelBeanInfo.class");
        deps.addElement (CAIV+"AS400TreePaneBeanInfo.class");
      }
    }
    else if (comp.equals (MESSAGE_VISUAL))
    {
      deps.addElement   (CAIV+"VMessageList.class");
      deps.addElement   (CAIV+"VMessageQueue.class");
      deps.addElement   (CAIV+"AS400ExplorerPane.class");
      deps.addElement   (CAIV+"AS400ListPane.class");
      if (includeBeans)
      {
        deps.addElement (CAIV+"VMessageListBeanInfo.class");
        deps.addElement (CAIV+"VMessageQueueBeanInfo.class");
        deps.addElement (CAIV+"AS400DetailsModelBeanInfo.class");
        deps.addElement (CAIV+"AS400DetailsPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400ExplorerPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400ListModelBeanInfo.class");
        deps.addElement (CAIV+"AS400ListPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400TreeModelBeanInfo.class");
        deps.addElement (CAIV+"AS400TreePaneBeanInfo.class");
      }
    }
    else if (comp.equals (PRINT_VISUAL))
    {
      deps.addElement   (CAIV+"VPrinters.class");
      deps.addElement   (CAIV+"AS400ExplorerPane.class");
      deps.addElement   (CAIV+"AS400ListPane.class");
      // Note - Pre-mod2 Toolbox erroneously refers to
      //        VOutput16.GIF, VOutput32.GIF (uppercase),
      //        therefore they won't get included.
      if (includeBeans)
      {
        deps.addElement (CAIV+"VPrinterBeanInfo.class");
        deps.addElement (CAIV+"VPrinterOutputBeanInfo.class");
        deps.addElement (CAIV+"VPrintersBeanInfo.class");
        deps.addElement (CAIV+"AS400DetailsModelBeanInfo.class");
        deps.addElement (CAIV+"AS400DetailsPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400ExplorerPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400ListModelBeanInfo.class");
        deps.addElement (CAIV+"AS400ListPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400TreeModelBeanInfo.class");
        deps.addElement (CAIV+"AS400TreePaneBeanInfo.class");
      }
    }
    else if (comp.equals (PROGRAM_CALL_VISUAL))
    {
      deps.addElement   (CAIV+"ProgramCallButton.class");
      deps.addElement   (CAIV+"ProgramCallMenuItem.class");
      if (includeBeans)
      {
        deps.addElement (CAIV+"ProgramCallButtonBeanInfo.class");
        deps.addElement (CAIV+"ProgramCallMenuItemBeanInfo.class");
      }
    }
    else if (comp.equals (RECORD_LEVEL_ACCESS_VISUAL))
    {
      deps.addElement   (CAIV+"RecordListFormPane.class");
      deps.addElement   (CAIV+"RecordListTablePane.class");
      if (includeBeans)
      {
        deps.addElement (CAIV+"RecordListFormPaneBeanInfo.class");
        deps.addElement (CAIV+"RecordListTableModelBeanInfo.class");
        deps.addElement (CAIV+"RecordListTablePaneBeanInfo.class");
      }
    }
    else if (comp.equals (USER_VISUAL))
    {
      deps.addElement   (CAIV+"VUserList.class");
      deps.addElement   (CAIV+"AS400ExplorerPane.class");
      deps.addElement   (CAIV+"AS400ListPane.class");
      if (includeBeans)
      {
        deps.addElement (CAIV+"VUserListBeanInfo.class");
        deps.addElement (CAIV+"AS400DetailsModelBeanInfo.class");
        deps.addElement (CAIV+"AS400DetailsPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400ExplorerPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400ListModelBeanInfo.class");
        deps.addElement (CAIV+"AS400ListPaneBeanInfo.class");
        deps.addElement (CAIV+"AS400TreeModelBeanInfo.class");
        deps.addElement (CAIV+"AS400TreePaneBeanInfo.class");
      }
    }

    else  // none of the above component values
      throw new IllegalArgumentException ("component (" +
                                          comp.intValue () + ")");

    return deps;
  }


  /**
   Returns the CCSIDs explicitly to be included.

   @return The CCSIDs explicitly to be included.
   The list will be empty if none has been specified.
   The list will contain only <code>Integer</code> objects.
   **/
  public Vector getCCSIDs () { return ccsids_; }


  /**
   Returns CCSIDs to be excluded.

   @return The CCSIDs to be excluded.
   The list will be empty if none has been specified.
   The list will contain only <code>Integer</code> objects.
   **/
  public Vector getCCSIDsExcluded () { return ccsidsExcluded_; }


  // @A3a
  /**
   Returns the name of the class file corresponding to a PCML file.

   @param pcmlEntryName The PCML entry name.
   @return The name of the class file corresponding to a PCML file.
   **/
  private static String getClassEntryForPcml (String pcmlEntryName)
  {
    int suffixPos = pcmlEntryName.lastIndexOf(".pcml");
    return (pcmlEntryName.substring(0,suffixPos) + ".class");
  }


  /**
   Returns the component ID for a component.

   @param componentName The component name.
   @return The associated ID for the component, or <code>NO_SUCH_COMPONENT</code>
           if the component name is not recognized.
   **/
  private static Integer getComponentID (String componentName)
  {
    String comp = componentName.trim ();
    Integer id = NO_SUCH_COMPONENT;  // default

    for (int i=0; i<VALID_COMPONENTS.length; ++i)
    {
      if (comp.equalsIgnoreCase (VALID_COMPONENTS[i]))
      {
        id = new Integer (i);
        break;
      }
    }
    return id;
  }


  /**
   Returns the required components specified by the user.

   @return The components specified by the user.
   The list will be empty if none has been specified.
   The list will contain only <code>Integer</code> objects.
   See <a href="../componentList.html">component list</a> for
   a list of integer values and associated components.
   **/
  public Vector getComponents () { return components_; }


  /**
   Returns the base directory under which the Toolbox language files
   will be searched for.
   This value is set by <code>setLanguageDirectory()</code>.
   @return The base directory for the language files.
   **/
  public File getLanguageDirectory () { return languageDirectory_; }


  /**
   Returns the national languages that explicitly are to be supported.
   The languages are identified by their Java locale name, such as fr_CA
   (for Canadian French).
   Note: Locale <code>en</code> is always implicitly supported.

   @return The national languages that explicitly are to be supported.
   The list will be empty if none has been specified.
   The list will contain only <code>String</code> objects.
   **/
  public Vector getLanguages () { return languages_; }


  /**
   Returns the best-fit shipped MRI suffix (such as "_fr")
   for a given language specifier (such as "_fr_FR").

   @param langId The language ID specified by the user.
   @param verbose The verbose mode.
   @return The shipped suffix most closely matching that ID;
           <code>null</code> if the language is not supported.
   **/
  private static String getShippedLanguageSuffixFor (String langId,
                                                     boolean verbose)
  {
    // Shipped suffixes are: de, de_CH, es, fr, fr_BE, fr_CA, fr_CH,
    // it, it_CH, ja, ko, zh, zh_TW, cs, hu, pl.

    // Note: cs, hu, and pl were not supported prior to mod1.

    // This routine will need to be updated if any languages are
    // added or dropped in subsequent releases of the Toolbox.

    String result = null;
    String id = normalizeLanguageSuffix (langId);

    if      (id.startsWith ("en")) {
      if (verbose)
        System.out.println ("English MRI files are included by default.");
    }
    else if (id.startsWith ("de_CH"))  result = "de_CH";
    else if (id.startsWith ("de"))     result = "de";
    else if (id.startsWith ("es"))     result = "es";
    else if (id.startsWith ("fr_BE"))  result = "fr_BE";
    else if (id.startsWith ("fr_CA"))  result = "fr_CA";
    else if (id.startsWith ("fr_CH"))  result = "fr_CH";
    else if (id.startsWith ("fr"))     result = "fr";
    else if (id.startsWith ("it_CH"))  result = "it_CH";
    else if (id.startsWith ("it"))     result = "it";
    else if (id.startsWith ("ja"))     result = "ja";
    else if (id.startsWith ("ko"))     result = "ko";
    else if (id.startsWith ("zh_TW"))  result = "zh_TW";
    else if (id.startsWith ("zh"))     result = "zh";
    else if (id.startsWith ("cs"))     result = "cs";  // added in mod1
    else if (id.startsWith ("hu"))     result = "hu";  // added in mod1
    else if (id.startsWith ("pl"))     result = "pl";  // added in mod1

    else {
      System.err.println ("Warning: Unsupported language ID specified: " +
                          langId + ".");
      result = id;  // try it anyway, it might be a new one
    }

    if (DEBUG)
      System.out.println ("Debug: Specified language suffix " + langId +
                          " maps to " + result);
    return result;
  }


  /**
   Reformats a user-supplied language specifier so that we have the
   best chance of recognizing it.
   @param language The language suffix.
   @return The normalized version of the suffix.  Never returns null.
   **/
  private static String normalizeLanguageSuffix (String language)
  {
    String result;
    String languageID = language;

    // Strip off any leading or trailing blanks, underscores.
    String id = language.trim ();
    while (id.charAt (0) == '_')
      id = id.substring (1);
    while (id.endsWith ("_"))
      id = id.substring (0, id.length ()-1);

    if (id.length () < 2)
      throw new IllegalArgumentException ("language (" + language + ")");
    else if (id.indexOf ("_") == 2)
      languageID = id;
    else {
      StringBuffer buf = new StringBuffer (id);
      buf.insert (2, '_');
      languageID = buf.toString ();
    }

    // Lower-case the chars before the first underscore, and uppercase the rest.
    String part1 = languageID.substring (0,2).toLowerCase ();
    String part2 = languageID.substring (2).toUpperCase ();
    result = part1 + part2;
    if (DEBUG) System.out.println ("Debug: Normalized language specifier: " +
                                    result);
    return result;
  }

  /**
   Parses and validates the arguments specified on the command line.

   @param args The command line arguments.
   @return An indication of whether the parse succeeded.
   **/
  private boolean parseArgs (String[] args)
  {
    boolean succeeded = false;

    // Wipe the slate clean, in case this AS400ToolboxJarMaker object is
    // being recycled.
    reset ();

    succeeded = arguments_.parse (args, this);
    return succeeded;
  }


  /**
   Resets the AS400ToolboxJarMaker object to a clean, default state,
   to facilitate object reuse.
   **/
  public void reset ()
  {
    super.reset ();
    arguments_ = new Arguments ();
    File defaultSourceJar = new File (DEFAULT_SOURCE_JAR_NAME);
    setSourceJar (defaultSourceJar);

    components_.removeAllElements ();
    languages_.removeAllElements ();
    languageDirectory_ = new File (System.getProperty ("user.dir"));
    ccsids_.removeAllElements ();
    ccsidsExcluded_.removeAllElements ();
  }


  /**
   Specifies the CCSIDs explicitly to be included.
   The conversion tables for only these CCSIDs (and CCSIDs
   specified in any prior invocations) will be included in the output.
   Conversion tables for other CCSIDs will <em>not</em> be included.
   <br>Note: This augments any previously specified CCSIDs.
   This method does not verify the existence of the specified CCSIDs.

   @param ccsidList The CCSIDs explicitly to be included.
   The list should contain only <code>Integer</code> objects.
   See <a href="../ccsidList.html">CCSIDs and encodings</a>
   for valid values.
   **/
  public void setCCSIDs (Vector ccsidList)
  {
    if (ccsidList == null)
      throw new NullPointerException ("ccsidList");
    // Check for nulls and for correct element type.
    ccsidList = validateList (ccsidList, "CCSID",
                              "java.lang.Integer", verbose_);
    Enumeration e = ccsidList.elements ();
    while (e.hasMoreElements ())
    {
      Integer ccsid = (Integer)e.nextElement ();
      addElement (ccsids_, ccsid);
      if (ccsidsExcluded_.contains (ccsid))
      {
        System.err.println ("Warning: CCSID " + ccsid.intValue () +
                            ", specified for both inclusion " +
                            "and exclusion, will be included.");
        ccsidsExcluded_.removeElement (ccsid);
      }
      //@A1a
      // If adding an ebcdic mixed-byte ccsid, also add associated ccsids
      // for "single-byte portion" and "double-byte portion".
      switch (ccsid.intValue())
      {
        case  930:
        case 5026:
          addElement (ccsids_, new Integer(290));
          addElement (ccsids_, new Integer(300));
          break;

        case  933:
        case 1364:
          addElement (ccsids_, new Integer(833));
          addElement (ccsids_, new Integer(834));
          break;

        case  935:
        case 1388:
          addElement (ccsids_, new Integer(836));
          addElement (ccsids_, new Integer(837));
          break;

        case  937:
          addElement (ccsids_, new Integer( 37));
          addElement (ccsids_, new Integer(835));
          break;

        case  939:
        case 5035:
          addElement (ccsids_, new Integer(1027));
          addElement (ccsids_, new Integer( 300));
          break;

        case 1399:
          addElement (ccsids_, new Integer( 5123));
          addElement (ccsids_, new Integer(16684));
          break;

        default:
          // None of the above, so nothing special to do.
      }
    }
  }

  /**
   Specifies CCSIDs to be excluded.
   The conversion tables for these CCSIDs will not be included in the output.
   <br>Note: This augments any previously specified CCSIDs.
   This method does not verify the existence of the specified CCSIDs.

   @param ccsidList The CCSIDs to be excluded.
   The list should contain only <code>Integer</code> objects.
   **/
  public void setCCSIDsExcluded (Vector ccsidList)
  {
    if (ccsidList == null)
      throw new NullPointerException ("ccsidList");
    // Check for nulls and for correct element type.
    ccsidList = validateList (ccsidList, "CCSID",
                              "java.lang.Integer", verbose_);
    Enumeration e = ccsidList.elements ();
    while (e.hasMoreElements ())
    {
      Integer ccsid = (Integer)e.nextElement ();
      // See if the CCSID was also specified to be *included*.
      if (ccsids_.contains (ccsid))
        System.err.println ("Warning: CCSID " + ccsid.intValue () +
                            ", specified for both exclusion " +
                            "and inclusion, will be included.");
      else
        addElement (ccsidsExcluded_, ccsid);
    }
  }


  /**
   Specifies required <i>IBM Toolbox for Java</i> components.
   Java Beans files associated with the components are <em>not</em>
   automatically included.
   <br>Note: This augments any previously specified components.
   If an unrecognized component is specified, a warning message is
   sent to <code>System.err</code>, and the component is ignored.

   @param components The required components.
   The list should contain only <code>Integer</code> objects.
   See <a href="../componentList.html">component list</a> for valid values.
   **/
  public void setComponents (Vector components)
  {
    setComponents (components, false); // do not include beans
  }


  /**
   Specifies required <i>IBM Toolbox for Java</i> components.
   <br>Note: This augments any previously specified components.
   If an unrecognized component is specified, a warning message is
   sent to <code>System.err</code>, and the component is ignored.

   @param components The required components.
   The list should contain only <code>Integer</code> objects.
   See <a href="../componentList.html">component list</a> for valid values.
   @param includeBeans Whether or not Java Beans files associated
   with the components are to be included.
   **/
  public void setComponents (Vector components, boolean includeBeans)
  {
    if (components == null)
      throw new NullPointerException ("componentList");
    // Check for nulls and for correct element type.
    components = validateList (components, "component",
                               "java.lang.Integer", verbose_);
    Vector filesForComponents = new Vector ();
    Enumeration e = components.elements ();
    while (e.hasMoreElements ())
    {
      Integer comp = (Integer)e.nextElement ();
      if (addElement (components_, comp)) // if not already in list...
      {
        Vector filesForThisComp = getBaseDependenciesForComponent (comp, includeBeans);
        copyVectorToFrom (filesForComponents, filesForThisComp, CHECK_DUPS); // @A3c
      }
    }

    // Add the component files to list of required files.
    setRequiredFiles (filesForComponents);
  }


  /**
   Specifies the base directory for additional Toolbox language files.
   The path below this directory should correspond to the package name
   the language files.
   <br>
   For example, if the MRI files are located in directories
   <code>/usr/myDir/com/ibm/as400/access</code> and
   <code>/usr/myDir/com/ibm/as400/vaccess</code>,
   then the base directory should be set to <code>/usr/myDir</code>.
   <br>This method does not verify the existence of the specified directory.
   <br>The default language directory is the current directory. 

   @param baseDirectory The base directory for the language files.
   **/
  public void setLanguageDirectory (File baseDirectory)
  {
    if (baseDirectory == null)
      throw new NullPointerException ("baseDirectory");
    else
      languageDirectory_ = baseDirectory;
  }


  /**
   Specifies national languages that explicitly are to be supported.
   Languages are identified by their Java locale name, such as
   <code>fr_CA</code>.
   The language files for the specified languages will be searched for
   in the directory tree specified by <code>setLanguageDirectory</code>,
   or, if no directory has been specified, in the directory tree
   under the current directory.
   <br>Note: This augments any previously specified languages.
   This method does not verify the existence of files for the specified
   languages.
   Locale <code>en</code> is always implicitly supported.
   If an unrecognized language is specified, a warning message is
   sent to <code>System.err</code>, and the language is ignored.

   @param languages The languages to be supported.
   The list should contain only <code>String</code> objects.
   **/
  public void setLanguages (Vector languages)
  {
    if (languages == null)
      throw new NullPointerException ("languageList");
    // Check for nulls and for correct element type.
    languages = validateList (languages, "language",
                              "java.lang.String", verbose_);

    // Map the specified languages to the actual shipped MRI name extensions.
    Enumeration e = languages.elements ();
    while (e.hasMoreElements ())
    {
      String specifiedLanguage = (String)e.nextElement ();  // e.g. "fr_CA"
      String mriSuffix = getShippedLanguageSuffixFor (specifiedLanguage, verbose_);
      addElement (languages_, mriSuffix);
    }
    // Note: Postpone calling setAdditionalFiles() until we need to, since
    // it needs to read the source JAR file and therefore may throw exceptions.
  }


  /**
   Specifies whether proxy-only files are to be excluded.
   Proxy files are needed only if the Toolbox's Proxy Service
   will be used.
   By default, all proxy files in the source JAR file are included.

   @param excludeProxies Whether or not proxy-only files
   are to be excluded.
   **/
  public void setProxyFilesExcluded (boolean excludeProxies)
  {
    noProxy_ = excludeProxies;
  }


  // @A4a
  /**
   Specifies whether AS400ToolboxJarMaker is allowed to selectively limit
   dependency expansion, and exclude certain components and packages
   that are unlikely to be needed.
   By default, this option is disabled, that is, all directly- and
   indirectly-referenced files in the source JAR file are included.
   Examples of files that may be excluded from the output:
   <ul>
   <li>JDBC classes, if component {@link #JDBC JDBC} has not been specified
   <li>class {@link com.ibm.as400.resource.RJob RJob}, if neither component {@link com.ibm.as400.access.Job Job} nor package <tt>com.ibm.as400.resource</tt> has been specified
   </ul>
   <em>Note: Dependency exclusion is not recommended for pre-V5R2 Toolbox JAR files.</em>

   @param excludeSomeDependencies Whether or not AS400ToolboxJarMaker should
   selectively limit dependency expansion.
   **/
  public void setExcludeSomeDependencies (boolean excludeSomeDependencies)
  {
    excludeSomeDependencies_ = excludeSomeDependencies;
  }


  /**
   Performs the actions specified in the invocation arguments.

   @param args The command line arguments.
   **/
  public static void main (String[] args)
  {
    try
    {
      AS400ToolboxJarMaker jm = new AS400ToolboxJarMaker ();

      if (jm.parseArgs (args))
      {
        if (jm.isSplit ())  // -split overrides all other options
        {
          File srcJar = jm.getSourceJar ();
          int splitSize = jm.getSplitSize ();
          jm.split (srcJar, splitSize); // unpack required files
        }
        else if (jm.isExtract ())
        {
          File srcJar = jm.getSourceJar ();
          File outputDir = jm.getExtractionDirectory ();
          jm.extract (srcJar, outputDir); // unpack required files
        }
        else
        {
          File srcJar = jm.getSourceJar ();
          File destJar = jm.getDestinationJar ();
          jm.makeJar (srcJar, destJar); // create a new JAR file
        }
      }
      else System.exit (1);
    }
    catch (Exception e) {
      System.err.println (e.toString ());
      if (DEBUG) e.printStackTrace (System.err);
      System.exit (1);
    }
    catch (Error e) {
      System.err.println (e.toString ());
      if (DEBUG) e.printStackTrace (System.err);
      System.exit (1);
    }

    System.exit (0);
  }



  class Arguments
  {
    private boolean expectingComponent_;
    private boolean expectingLanguage_;
    private boolean expectingLanguageDir_;
    private boolean expectingCcsid_;
    private boolean expectingCcsidExcluded_;

    /**
     Parses and validates the arguments specified on the command line.

     @param arguments The command line arguments.
     @param jmaker The object to apply the arguments to.
     @return An indication of whether the parse succeeded.
     **/
    boolean parse (String[] arguments, AS400ToolboxJarMaker jmaker)
    {
      Vector components = null; // Strings
      Vector languages = null; // Strings
      Vector ccsids = null; // Integers
      Vector ccsidsExcluded = null; // Integers
      boolean includeBeans = false;
      boolean noProxySpecified = false;
      boolean succeeded = true;

      // Submit the arguments to the superclass first.
      if (!jmaker.parseArgs (arguments, true)) // 2nd arg tells superclass
      {                                 // to tolerate unrecognized options.
        printUsage (System.err);
        return false;
      }

      // Get the args that the superclass didn't recognize.
      String[] args = jmaker.getUnrecognizedArgs ();
      if (DEBUG)
      {
        System.out.print ("Debug: Arguments: ");
        for (int i=0; i<args.length; i++)
          System.out.print (args[i] + " ");
        System.out.println ();
      }

      if (args.length == 0) {
        if (requestedUsageInfo_) {
          printUsage (System.out);
          return false;
        }
        else
          return succeeded;  // the superclass handled all the arguments
      }

      boolean priorTokenWasUnrecognized = false;

      // Parse the arguments.
      for (int i = 0; i < args.length; ++i)
      {
        // Check for option tag.
        if (args[i].charAt (0) == '-')
        {
          resetExpectations ();
          priorTokenWasUnrecognized = false;

          // component tag
          if ((args[i].equalsIgnoreCase ("-c")) ||
              (args[i].equalsIgnoreCase ("-component")) ||
              (args[i].equalsIgnoreCase ("-components")))
            expectingComponent_ = true;
          // expect the next token(s) to be component(s)

          // language tag
          else if ((args[i].equalsIgnoreCase ("-l")) ||
                   (args[i].equalsIgnoreCase ("-language")) ||
                   (args[i].equalsIgnoreCase ("-languages")))
            expectingLanguage_ = true;
          // expect the next token(s) to be language(s)

          // languageDirectory tag
          else if ((args[i].equalsIgnoreCase ("-ld")) ||
                   (args[i].equalsIgnoreCase ("-languageDirectory")))
            expectingLanguageDir_ = true;
          // expect the next token to be directory

          // ccsid tag
          else if ((args[i].equalsIgnoreCase ("-cc")) ||
                   (args[i].equalsIgnoreCase ("-ccsid")) ||
                   (args[i].equalsIgnoreCase ("-ccsids")))
            expectingCcsid_ = true;
          // expect the next token(s) to be CCSID(s)

          // ccsidExcluded tag
          else if ((args[i].equalsIgnoreCase ("-cx")) ||
                   (args[i].equalsIgnoreCase ("-ccx")) ||
                   (args[i].equalsIgnoreCase ("-ccsidExcluded")) ||
                   (args[i].equalsIgnoreCase ("-ccsidsExcluded")))
            expectingCcsidExcluded_ = true;
          // expect the next token(s) to be CCSID(s)

          // beans tag
          else if ((args[i].equalsIgnoreCase ("-b")) ||
                   (args[i].equalsIgnoreCase ("-beans")))
            includeBeans = true;

          // noProxy tag
          else if ((args[i].equalsIgnoreCase ("-np")) ||
                   (args[i].equalsIgnoreCase ("-noProxy")) ||
                   (args[i].equalsIgnoreCase ("-noProxies")))
          {
            noProxy_ = true;
            noProxySpecified = true;
          }

          // excludeSomeDependencies tag                                @A4a
          else if ((args[i].equalsIgnoreCase ("-xd")) ||
                   (args[i].equalsIgnoreCase ("-excludeSomeDependencies")))
          {
            excludeSomeDependencies_ = true;
          }

          else
          {
            System.err.println("Error: Unrecognized option: " + args[i]);
            priorTokenWasUnrecognized = true;
            succeeded = false;
          }
        }

        // Handle non-option-tag entry.
        else
        {
          if (priorTokenWasUnrecognized)
          {
            System.err.println("Error: Argument after unrecognized option: " +
                               args[i]);
          }

          else if (expectingComponent_)
          {
            // Parse the list of components, separated by commas.
            StringTokenizer st = new StringTokenizer (args[i], ",");
            if (st.countTokens () != 0)
            {
              expectingComponent_ = false;
              if (components == null)
                components = new Vector (st.countTokens ());
              boolean badComponent = false;
              while (st.hasMoreTokens ()) {
                String token = st.nextToken ();
                Integer component = getComponentID (token);
                if (component.equals (NO_SUCH_COMPONENT))
                {
                  System.err.println ("Error: Invalid component name: " + token);
                  badComponent = true;
                  succeeded = false;
                }
                else
                  addElement (components, component);
              }
              if (badComponent && jmaker.isVerbose())
              {
                System.err.println ("The recognized components are:");
                int j;
                for (j=0; j<VALID_COMPONENTS.length-1; ++j)
                  System.err.print (VALID_COMPONENTS[j] + ", ");
                System.err.println (VALID_COMPONENTS[j]);
              }
            }
          }

          else if (expectingLanguage_)
          {
            // Parse the list of languages, separated by commas.
            StringTokenizer st = new StringTokenizer (args[i], ",");
            if (st.countTokens () != 0)
            {
              expectingLanguage_ = false;
              if (languages == null)
                languages = new Vector (st.countTokens ());
              while (st.hasMoreTokens ())
                addElement (languages, st.nextToken ());
            }
          }

          else if (expectingLanguageDir_)
          {
            expectingLanguageDir_ = false;
            jmaker.setLanguageDirectory (new File (args[i]));
          }

          else if (expectingCcsid_)
          {
            // Parse the list of CCSIDs, separated by commas.
            StringTokenizer st = new StringTokenizer (args[i], ",");
            if (st.countTokens () != 0)
            {
              expectingCcsid_ = false;
              if (ccsids == null)
                ccsids = new Vector (st.countTokens ());
              while (st.hasMoreTokens ())
              {
                String token = st.nextToken ();
                Integer ccsid = null;
                try { ccsid = new Integer (token); }
                catch (NumberFormatException e) {
                  System.err.println ("Error: Non-integer CCSID value: " + token);
                  succeeded = false;
                  continue; // skip to next token in list
                }
                addElement (ccsids, ccsid);
              }
            }
          }

          else if (expectingCcsidExcluded_)
          {
            // Parse the list of CCSIDs, separated by commas.
            StringTokenizer st = new StringTokenizer (args[i], ",");
            if (st.countTokens () != 0)
            {
              expectingCcsidExcluded_ = false;
              if (ccsidsExcluded == null)
                ccsidsExcluded = new Vector (st.countTokens ());
              while (st.hasMoreTokens ())
              {
                String token = st.nextToken ();
                Integer ccsid = null;
                try {ccsid = new Integer (token);}
                catch (NumberFormatException e) {
                  System.err.println ("Error: Non-integer CCSID value: " + token);
                  succeeded = false;
                  continue; // skip to next token in list
                }
                addElement (ccsidsExcluded, ccsid);
              }
            }
          }

          else  // None of the above.
          {
            System.err.println ("Error: Unrecognized argument: " + args[i]);
            succeeded = false;
          }

          priorTokenWasUnrecognized = false;
          resetExpectations (); // We expect the next token to be an option
        }
      }  // end of 'for' loop

      resetExpectations ();  // clean up

      if (jmaker.isSplit ())
      {
        if ((components != null) ||
            (includeBeans == true) ||
            (languages != null) ||
            (ccsids != null) ||
            (ccsidsExcluded != null))
        {
          System.err.println ("Warning: When -split is specified, " +
                              "all other options are ignored, except " +
                              "-source and -verbose.");
        }
      }
      else  // not a split
      {
        // Check for sufficient options.
        if (!jmaker.isOptionInfoSufficient () && // enough options for superclass
            (components == null) &&
            (languages == null) &&
            (ccsids == null) &&
            (ccsidsExcluded == null) &&
            (noProxySpecified == false))
        {
          System.err.println("Error: Need to specify more options.");
          succeeded = false;
        }

        // Set any languages.
        if (languages != null)
          setLanguages (languages);

        if (components != null)
        {
          if (components.size () != 0)
            setComponents (components, includeBeans);
          else succeeded = false;  // bogus components
        }
        if (ccsids != null)
          setCCSIDs (ccsids);
        if (ccsidsExcluded != null)
          setCCSIDsExcluded (ccsidsExcluded);
      }

      if (!succeeded)
        printUsage (System.err);

      return succeeded;
    }

    /**
     Prints the usage information.

     @param output   The output stream.
     **/
    private void printUsage (PrintStream output)
    {
      output.println ();
      output.println ("Usage: ");
      output.println ();
      output.println ("  AS400ToolboxJarMaker [-source jarFile]");
      output.println ("                       [-destination jarFile]");
      output.println ("                       [-requiredFile entry1[,entry2[...]]]");
      output.println ("                       [-additionalFile file1[,file2[...]]]");
      output.println ("                       [-additionalFilesDirectory directory");
      output.println ("                       [-package pkg1[,pkg2[...]]]");
      output.println ("                       [-extract [directory]]");
      output.println ("                       [-split [kilobytes]]");
      output.println ("                       [-component comp1[,comp2[...]]]");
      output.println ("                       [-beans]");
      output.println ("                       [-language language1[,language2[...]]]");
      output.println ("                       [-languageDirectory directory");
      output.println ("                       [-ccsid ccsid1[,ccsid2[...]]]");
      output.println ("                       [-ccsidExcluded ccsid1[,ccsid2[...]]]");
      output.println ("                       [-noProxy]");
      output.println ("                       [-excludeSomeDependencies]");  // @A4a
      output.println ("                       [-verbose]");
      output.println ("                       [-help]");
      output.println ();
      output.println ("At least one of the following options must be specified: ");
      output.println ("-requiredFile, -additionalFile, -package, -extract, -split, " +
                      "-component, -language, -ccsid, -ccsidExcluded, -noProxy");
      output.println ();
      output.println ("The -excludeSomeDependencies option is not recommended " +
                      "for pre-V5R2 Toolbox JAR files.");
    }

    private void resetExpectations ()
    {
      if (expectingComponent_)
        System.err.println ("Warning: No component specified after -component.");
      if (expectingLanguage_)
        System.err.println ("Warning: No language specified after -language.");
      if (expectingLanguageDir_)
        System.err.println ("Warning: No directory specified after -languageDirectory.");
      if (expectingCcsid_)
        System.err.println ("Warning: No CCSID specified after -ccsid.");
      if (expectingCcsidExcluded_)
        System.err.println ("Warning: No CCSID specified after -ccsidExcluded.");

      expectingComponent_ = false;
      expectingLanguage_ = false;
      expectingLanguageDir_ = false;
      expectingCcsid_ = false;
      expectingCcsidExcluded_ = false;
    }

  }

}
