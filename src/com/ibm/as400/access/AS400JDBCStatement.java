///////////////////////////////////////////////////////////////////////////////
//                                                                             
// JTOpen (AS/400 Toolbox for Java - OSS version)                              
//                                                                             
// Filename: AS400JDBCStatement.java
//                                                                             
// The source code contained herein is licensed under the IBM Public License   
// Version 1.0, which has been approved by the Open Source Initiative.         
// Copyright (C) 1997-2000 International Business Machines Corporation and     
// others. All rights reserved.                                                
//                                                                             
///////////////////////////////////////////////////////////////////////////////

package com.ibm.as400.access;

import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.Enumeration;
import java.util.Vector;



// @E6C - Changed javadoc paragraph about thread-safety.
/**
<p>The AS400JDBCStatement class provides a mechanism for
executing static SQL statements. Use Connection.createStatement()
to create new Statement objects.

<p>Only one result set per statement can be open at any point in time.
Therefore, if an application needs to read from multiple result sets,
then each must be generated by a different statement.

<p>AS400JDBCStatements are thread-safe.

<p>Note that the connection keeps a reference to each statement that
it creates.  This means that statements will not get garbage collected
until the connection gets garbage collected.  It is best to 
explicitly close statements rather than counting on garbage collection.
**/
//
// Implementation notes:
//
// 1. The RPB is used to provide parameters for requests.
//    If we make a request without specifying some of the
//    parameters, then the server will look in the RPB.
//
//    Specifically, we use an RPB for each statement object to
//    store parameters that do not depend on the SQL statement:
//
//    * cursor name
//    * statement name
//
// 2. There are many package-scope members in this class
//    heirarchy which really should be "private protected".
//    However, that is no longer allowed in Java, so we
//    at least limit access out the the package.  They
//    are not intended to be used outside of the class
//    heirarchy.
//
public class AS400JDBCStatement
implements Statement
{
  private static final String copyright = "Copyright (C) 1997-2000 International Business Machines Corporation and others.";




    // Constants.
    static final int            MAX_CURSOR_NAME_LENGTH = 18;



    // Private data.
                boolean                 allowImmediate_;        // private protected
                Vector                  batch_;                 // private protected
    private     String                  blockCriteria_;
    private     int                     blockSize_;
    private     boolean                 cancelled_;
    private     boolean				    closed_;
                AS400JDBCConnection		connection_;            // private protected
                JDCursor                cursor_;                // private protected
    private     String                  cursorDefaultName_;
    private     boolean                 escapeProcessing_;
    private     int                     fetchDirection_;
    private     int                     fetchSize_;
                int                     id_;                    // private protected
                Object                  internalLock_;          // private protected    // @E6A
    private     boolean                 lastPrepareContainsLocator_;                    // @B2A
    private     int                     maxFieldSize_;
	private     int					    maxRows_;
    private     String                  name_;
    private     String                  nameOverride_;
	            int                     numberOfResults_;       // private protected
	            boolean                 prefetch_;              // private protected
	private     int                     queryTimeout_;
	            AS400JDBCResultSet		resultSet_;             // private protected
    private     int                     rowCountEstimate_;                              // @ECA
	private     boolean                 rpbCreated_;
	private     boolean                 rpbSyncNeeded_;
	            JDPackageManager        packageManager_;        // private protected
	            int                     resultSetConcurrency_;  // private protected
	private     int                     resultSetType_;
                SQLConversionSettings   settings_;              // private protected
    private     SQLWarning		        sqlWarning_;
                JDTransactionManager    transactionManager_;    // private protected
	            int					    updateCount_;           // private protected
    private     String				    packageCriteria_;             // @A1A



/**
Constructs an AS400JDBCStatement object.

@param  connection              The connection to the server.
@param  id                      The id.
@param  transactionManager      The transaction manager for the connection.
@param  packageManager          The package manager for the connection.
@param  blockCriteria           The block criteria.
@param  blockSize               The block size (in KB).
@param  prefetch                Indicates if prefetching data.
@param  packageCriteria         The package criteria.
@param  resultSetConcurrency    The result set concurrency.
@param  resultSetType           The result set type.

@exception  SQLException    If an error occurs.
**/
    AS400JDBCStatement (AS400JDBCConnection connection,
                        int id,
                        JDTransactionManager transactionManager,
                        JDPackageManager packageManager,
                        String blockCriteria,
                        int blockSize,
                        boolean prefetch,
                        String packageCriteria,      // @A1C
                        int resultSetType,
                        int resultSetConcurrency)
        throws SQLException
    {
		// Initialization.
		allowImmediate_         = true;
		batch_                  = new Vector ();
		blockCriteria_          = blockCriteria;
		blockSize_              = blockSize;
		cancelled_              = false;
		closed_				    = false;
		connection_			    = connection;
		escapeProcessing_       = true;
		fetchDirection_         = ResultSet.FETCH_FORWARD;
		fetchSize_              = 0;
		id_                     = id;
        internalLock_           = new Object();             // @E6A
		maxFieldSize_           = 0;
		maxRows_                = 0;
		numberOfResults_        = 0;
		prefetch_               = prefetch;
		queryTimeout_           = 0;
		resultSet_			    = null;
		transactionManager_     = transactionManager;
		updateCount_		    = -1;
        packageManager_         = packageManager;
        resultSetConcurrency_   = resultSetConcurrency;
        resultSetType_          = resultSetType;
        rpbCreated_             = false;
        rpbSyncNeeded_          = true;
		settings_               = new SQLConversionSettings (connection_);
        sqlWarning_             = null;
        packageCriteria_        = packageCriteria;  // @A1A

		// By default, the statement name and cursor name are
		// based on the id.
		String idString	= "0000" + id;
		String idString4 = idString.substring (idString.length() - 4);
		name_ = "STMT" + idString4;
        if (resultSetType_ == ResultSet.TYPE_FORWARD_ONLY)          // @B1A
		    cursorDefaultName_ = "CRSR" + idString4;
        else                                                        // @B1A
            cursorDefaultName_ = "SCRSR" + idString4;               // @B1A

        // @E4D // Use lazy close only when the "lazy close" property                                      @E4A
        // @E4D // has been set AND the old auto-commit support is                                         @E4A
        // @E4D // still in effect.                                                                        @E4A
        // @E4D boolean lazyClose = connection_.getProperties().getBoolean(JDProperties.LAZY_CLOSE)     // @E4A
        // @E4D                     && transactionManager_.isNewAutoCommitSupport();                    // @E4A

		cursor_ = new JDCursor (connection_, id_, cursorDefaultName_, resultSetConcurrency_);           // @E4C @EAC

        // Trace messages.
        if (JDTrace.isTraceOn()) {
            JDTrace.logOpen (this);
            JDTrace.logProperty (this, "Escape processing", escapeProcessing_);
            JDTrace.logProperty (this, "Fetch direction", fetchDirection_);
            JDTrace.logProperty (this, "Fetch size", fetchSize_);
            JDTrace.logProperty (this, "Max field size", maxFieldSize_);
            JDTrace.logProperty (this, "Max rows", maxRows_);
            JDTrace.logProperty (this, "Query timeout", queryTimeout_);
            JDTrace.logProperty (this, "Result set conncurrency", resultSetConcurrency_);
            JDTrace.logProperty (this, "Result set type", resultSetType_);
        }
    }



// JDBC 2.0
/**
Adds an SQL statement to the current batch of SQL statements.

@param sql  The SQL statement to be added to the current batch.
            This can be any SQL statement that does not return
            a result set.

@exception SQLException     If the statement is not open or
                            the SQL statement contains a syntax
                            error.
**/
    public void addBatch (String sql)
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
    		JDSQLStatement sqlStatement = new JDSQLStatement (sql,
    		    settings_.getDecimalSeparator (), escapeProcessing_,
    		    packageCriteria_);
    
            // Validate that no parameters are set, since parameters
            // imply the need for a PreparedStatement.
            if (sqlStatement.countParameters () > 0)
                JDError.throwSQLException (JDError.EXC_PARAMETER_COUNT_MISMATCH);
    
            batch_.addElement (sqlStatement);
        }
    }



/**
Cancels the statement.  This is useful when one thread
needs to cancel a statement that is being executed by another
thread.  This will close the current result set.

@exception  SQLException    If the statement is not open or
                            an error occurs.
**/
    public void cancel ()
      throws SQLException
    {
        // Don't synchronize this method... it needs to be callable             // @E6A
        // even when the statement is busy.                                     // @E6A
        checkOpen ();

        connection_.cancel(id_);                                                // @E5A

        cancelled_ = true;
		closeResultSet (JDCursor.REUSE_YES);
    }



/**
Checks that the statement is open.  Public methods
that require an open statement should call this first.

@exception  SQLException    If the statement is not open.
**/
    void checkOpen ()
        throws SQLException
    {
        connection_.checkOpen ();
        if (closed_)
            JDError.throwSQLException (JDError.EXC_FUNCTION_SEQUENCE);
    }



// JDBC 2.0
/**
Clears the current batch of SQL statements.

@exception SQLException     If the statement is not open.
**/
    public void clearBatch ()
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
            batch_.removeAllElements ();
        }                                                                      
    }



/**
Clears all warnings that have been reported for the statement.
After this call, getWarnings() returns null until a new warning
is reported for the statement.

@exception SQLException If an error occurs.
**/
    public void clearWarnings ()
      throws SQLException
    {
		sqlWarning_ = null;
    }



/**
Releases the statement's resources immediately instead of waiting
for them to be automatically released.  This closes the current
result set.

@exception SQLException If an error occurs.
**/
//
// Implementation note:
//
// It is a requirement to not get replies during a finalize()
// method.  Since finalize() calls this method, this requirement
// applies here, too.
//
    public void close ()
      throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            // If this is already closed, then just do nothing.          
            // 
            // The spec does not define what happens when a connection
            // is closed multiple times.  The official word from the Sun 
            // JDBC team is that "the driver's behavior in this case 
            // is implementation defined.   Applications that do this are 
            // non-portable." 
            if (isClosed ())
                return;
    
            // Close the current result set.  (Note: This has no
            // effect if the user explicitly closed the result set
            // before closing the statement.
            if (! cursor_.isClosed()) {                                     // @B3A
                closeResultSet (JDCursor.REUSE_NO);
            }                                                               // @B3A
    
            // If, even after closing the current result set,
            // there are more result sets that were returned, we
            // need to close them, too.  At first I though we
            // would have to Open/Describe and Close each one
            // in turn, but the database server allows us to 
            // close the current cursor with REUSE_NO to close
            // all remaining result sets.  The catch is that we
            // need to have an open cursor before closing it, so
            // we open the next cursor, then close it again.
            // This closes all remaining result sets.
            if (numberOfResults_ > 1) { 
                getMoreResults ();
                cursor_.close (JDCursor.REUSE_NO);
            }
    
            // Delete the RPB.  Remember the error information                                             @EDC
            // in order to report later...                                                                 @EDC
            SQLException e = null;                                                                      // @EDA
            if (rpbCreated_) {                                                                          // @EDA
           		DBSQLRPBDS request3 = new DBSQLRPBDS (
            	    DBSQLRPBDS.FUNCTIONID_DELETE_RPB, id_,
            	    DBBaseRequestDS.ORS_BITMAP_RETURN_DATA, 0);                                         // @E8C @EDC
        	    DBReplyRequestedDS reply = connection_.sendAndReceive(request3, id_);                   // @EDC
        
    	        int errorClass = reply.getErrorClass();                                                 // @EDA
       	        int returnCode = reply.getReturnCode();                                                 // @EDA
                if (errorClass != 0) {                                                                  // @EDA
                    if (returnCode < 0) {                                                               // @EDA
                        try {                                                                           // @EDA
                    	    JDError.throwSQLException(connection_, id_, errorClass, returnCode);        // @EDA
                        }                                                                               // @EDA
                        catch(SQLException e2) {                                                        // @EDA
                            e = e2;                                                                     // @EDA
                        }                                                                               // @EDA
                    }                                                                                   // @EDA
                    else {                                                                              // @EDA
        	            postWarning (JDError.getSQLWarning(connection_, id_, errorClass, returnCode));  // @EDA
                    }                                                                                   // @EDA
           	    }                                                                                       // @EDA
            }                                                                                           // @EDA

       		// Delete the ORS.
       		//
       		// @EDD // We must use get a reply here even though we do not
       		// @EDD // need any information from it.  Otherwise the next
       		// @EDD // flow would be based on this ORS, which gets deleted.
       		// @EDD // In that case, we would always get an "ORS not found"
       		// @EDD // error.
       		// @EDD //
       		// @EDD // In this case, we also need it to force a send of
       		// @EDD // all of the previous datastreams, since this is the
       		// @EDD // last one for this statement.
       		//
            // Make sure not to base future requests on this ORS.                                   // @EDA
            //
        	DBSQLResultSetDS request2 = new DBSQLResultSetDS (
    	        DBSQLResultSetDS.FUNCTIONID_DELETE_RESULTS_SET,
    	        id_, 0, 0);                                                                         // @EDC
            connection_.send(request2, id_, false);                                                 // @EDC
    
            // Ignore errors, since we would not be able to get
            // the message text anyway (because the ORS is gone.)
    
    		closed_ = true;
    		connection_.notifyClose (this, id_);
    
            if (JDTrace.isTraceOn())
                JDTrace.logClose (this);

            // Rethrow any exception that surfaced when deleting the RPB.                              @EDA
            if (e != null)                                                                          // @EDA
                throw e;                                                                            // @EDA
        }
    }



/**
Closes the result set and cursor.

@param      reuseFlag   Either JDCursor.REUSE_NO,
                        JDCursor.REUSE_YES, or
                        JDCursor.REUSE_RESULT_SET.

@exception  SQLException    If an error occurs.
**/
    void closeResultSet (int reuseFlag) // private protected
		throws SQLException
    {
		if (resultSet_ != null) {
		    if (! resultSet_.isClosed ())
    			resultSet_.close ();
			resultSet_ = null;
		}

		if (! cursor_.isClosed ())
        	cursor_.close (reuseFlag);

		updateCount_ = -1;
	}



/**
Executes an SQL statement on the server.

@param  sqlStatement    The SQL statement.
@param  resultRow       The result row or null if none.

@exception      SQLException    If the query timeout limit is
                                exceeded or an error occurs.
**/
//
// Do not override this method.  Instead, override
// commonExecuteBefore() and commonExecuteAfter() as needed.
//
    void commonExecute (JDSQLStatement sqlStatement,
                        JDServerRow resultRow) // private protected
        throws SQLException
    {
        cancelled_ = false;

        // If the statement is not immediately executable, then
        // we still need to do the execute.  Otherwise, the execute
        // was already done as part of the prepare.
        if ((! allowImmediate_) || (! sqlStatement.isImmediatelyExecutable ())) {

            // Sync up the RPB.
            syncRPB ();

            boolean usedNameOverride = false;

            // This boolean is true when an Open is needed and
            // false when an Execute is needed.
            boolean openNeeded = (resultRow != null);

            // If we are prefetching data and a row format
            // was returned, then fetch the first block of data.
            boolean fetchFirstBlock = ((prefetch_) && (openNeeded));

    		// Send the execute data stream.
	    	try {
		        // Determine the appropriate function id, based
		        // on whether we want to prefetch data, and on whether
		        // this is an Execute or an Open.
    		    int functionId;
    		    if (openNeeded) {
                    if (fetchFirstBlock)
                        functionId = DBSQLRequestDS.FUNCTIONID_OPEN_DESCRIBE_FETCH;
                    else
                        functionId = DBSQLRequestDS.FUNCTIONID_OPEN_DESCRIBE;
                }
                else
                    functionId = DBSQLRequestDS.FUNCTIONID_EXECUTE;

    			DBSQLRequestDS request = new DBSQLRequestDS (functionId, id_,
	    		    DBSQLRequestDS.ORS_BITMAP_RETURN_DATA
                    + DBSQLRequestDS.ORS_BITMAP_SQLCA, 0);

                int openAttributes = 0;
                if (openNeeded) {
                    openAttributes = cursor_.getOpenAttributes (sqlStatement, blockCriteria_);
            		request.setOpenAttributes (openAttributes);
                }

    	    	if (nameOverride_.length() != 0) {
    		        request.setPrepareStatementName (nameOverride_, connection_.getConverter ());
    		        usedNameOverride = true;
        		}

    	    	if (packageManager_.isEnabled())
	    	        if (sqlStatement.isPackaged())
		                request.setPackageName (packageManager_.getName (), connection_.getConverter ());

                // If we are prefetching data and a row format
                // was returned, then set the blocking factor.
                if (fetchFirstBlock) {
                    request.addOperationResultBitmap (
                        DBSQLRequestDS.ORS_BITMAP_RESULT_DATA);
                    request.setBlockingFactor (getBlockingFactor (sqlStatement,
                    fetchFirstBlock ? resultRow.getRowLength() : 0));
                }

                if (resultSetType_ == ResultSet.TYPE_FORWARD_ONLY)
                    request.setScrollableCursorFlag (0);
                else
                    request.setScrollableCursorFlag (1);

                commonExecuteBefore (sqlStatement, request);

    			DBReplyRequestedDS reply = connection_.sendAndReceive (request, id_);

                // Gather information from the reply.
                cursor_.processConcurrencyOverride(openAttributes, reply);  // @E1A @EAC
                transactionManager_.processCommitOnReturn(reply);           // @E2A
                DBReplySQLCA sqlca = reply.getSQLCA ();
                DBData resultData = null;
                if (fetchFirstBlock)
                    resultData = reply.getResultData ();

                // Check for server errors.  Take note on prefetch
                // if the last block was fetched.
  		        int errorClass = reply.getErrorClass();
   	            int returnCode = reply.getReturnCode();

                // Remember that a cursor is open even when most
                // errors occur.
                //
                // Except:
                //   * When a query timeout occurs, the server
                //     does not leave a cursor open.
                if ((openNeeded)
                    && ((errorClass != 1) || (returnCode != -666)))
                    cursor_.setState (false);

                // Take note on prefetch if the last block was fetched.
                boolean lastBlock = false;
                if (((errorClass == 1) && (returnCode == 100))
                    || ((errorClass == 2) && (returnCode == 701)))
      	        	lastBlock = true;

                else if (errorClass != 0) {
              	    if (returnCode < 0)
                	    JDError.throwSQLException (connection_, id_, errorClass, returnCode);
                	else
    	                postWarning (JDError.getSQLWarning (connection_, id_, errorClass, returnCode));
       	    	}

                // Compute the update count and result set .
                if (openNeeded) {
                    JDServerRowCache rowCache;
                    if ((fetchFirstBlock) && (resultData != null))
                        rowCache = new JDServerRowCache (resultRow,
                            connection_, id_,
                            getBlockingFactor (sqlStatement,
                            resultRow.getRowLength()), resultData,
                            lastBlock);
                    else
                        rowCache = new JDServerRowCache (resultRow,
                            connection_, id_,
                            getBlockingFactor (sqlStatement,
                            resultRow.getRowLength()));

                    // If the result set concurrency is updatable, check to                            @E1C
                    // see if the server overrode the cursor type to read only.                        @E1C
                    // Don't worry about the other direction (server overrides                         @E1C
                    // from read-only to updatable).                                                   @E1C
                    int actualConcurrency = (resultSetConcurrency_ == ResultSet.CONCUR_UPDATABLE)   // @E1C
                        ? cursor_.getConcurrency() : resultSetConcurrency_;                         // @E1C @EAC

                    updateCount_ = -1;                                                              // @ECM
                    rowCountEstimate_ = sqlca.getErrd3();                                           // @ECA
                    resultSet_ = new AS400JDBCResultSet (this,
                        sqlStatement, rowCache, connection_.getCatalog(),
                        cursor_.getName(), maxRows_, resultSetType_,
                        actualConcurrency, fetchDirection_, fetchSize_);                            // @E1C
                    if (resultSet_.getConcurrency () != resultSetConcurrency_)
                        postWarning (JDError.getSQLWarning (JDError.WARN_OPTION_VALUE_CHANGED));
                }
                else {
                    updateCount_ = sqlca.getErrd3 ();
                    rowCountEstimate_ = -1;                                                         // @ECC
                }

                // Compute the number of results.
                boolean isCall = (sqlStatement.getNativeType () == JDSQLStatement.TYPE_CALL);
                if (isCall)
                    numberOfResults_ = sqlca.getErrd2 ();
                else
                    numberOfResults_ = 0;

                // If this is a CALL and result sets came back, but
                // no format was returned, then open the cursor. The
                // result set must be forward only and read only.
                // This is a server restriction.                                    @EBA
                if (sqlStatement != null) {
                    if ((isCall) && (numberOfResults_ > 0) && (resultSet_ == null)) {
                        JDServerRow row = new JDServerRow (
                            connection_, id_, cursor_.openDescribe (openAttributes,
                            false), settings_);
                        JDServerRowCache rowCache = new JDServerRowCache (row,
                            connection_, id_, getBlockingFactor (sqlStatement,
                            row.getRowLength()));
                        resultSet_ = new AS400JDBCResultSet (this,
                            sqlStatement, rowCache, connection_.getCatalog(),
                            cursor_.getName(), maxRows_, ResultSet.TYPE_FORWARD_ONLY,
                            ResultSet.CONCUR_READ_ONLY, fetchDirection_,
                            fetchSize_);                         
                        if (resultSet_.getConcurrency () != resultSetConcurrency_)
                            postWarning (JDError.getSQLWarning (JDError.WARN_OPTION_VALUE_CHANGED));
                    }
                }

	    		commonExecuteAfter (sqlStatement, reply);
            }
    		catch (DBDataStreamException e) {
	    		JDError.throwSQLException (JDError.EXC_INTERNAL, e);
		    }

            // Inform the transaction manager that a statement
            // was executed.
            transactionManager_.statementExecuted ();

            // Check to see if the statement was cancelled.
            if (cancelled_)
                JDError.throwSQLException (JDError.EXC_OPERATION_CANCELLED);

            // Output a summary as a trace message.   The * signifies that the
            // statement name comes from the RPB.
            if (JDTrace.isTraceOn()) {
                JDTrace.logInformation (this,
                    "Executed " + (usedNameOverride ? (nameOverride_) : (name_ + "*"))
                    + " [" + sqlStatement + "]");
                JDTrace.logInformation (this,
                    "Update count = " + updateCount_);
                JDTrace.logInformation (this,
                    "Result set = " + (resultSet_ != null));
                JDTrace.logInformation (this,
                    "Number of result sets = " + numberOfResults_);
                JDTrace.logInformation (this,                                               // @ECA
                    "Row count estimate = " + rowCountEstimate_);                           // @ECA
            }
        }
    }



/**
Performs common operations needed after an execute.

@param  sqlStatement    The SQL statement.
@param  reply           The execute reply.

@exception      SQLException    If an error occurs.
**/
//
// This method is intended to be overriden, if needed.
//
    void commonExecuteAfter (JDSQLStatement sqlStatement,
                             DBReplyRequestedDS reply) // private protected
        throws SQLException
    {
        // Nothing.
    }



/**
Performs common operations needed before an execute.

@param  sqlStatement    The SQL statement.
@param  request         The execute request.

@exception      SQLException    If an error occurs.
**/
//
// This method is intended to be overriden, if needed.
//
    void commonExecuteBefore (JDSQLStatement sqlStatement,
                              DBSQLRequestDS request) // private protected
        throws SQLException
    {
        // Clear warnings.
		clearWarnings ();
    }



/**
Prepares (pre-compiles) the SQL statement on the server.

@param   sqlStatement   The SQL statement.
@return                 The result row or null if none.

@exception  SQLException    If an error occurs.
**/
//
// Do not override this method.  Instead, override
// commonPrepareBefore(), commonPrepareAfter() and
// commonPrepareBypass() as needed.
//
    JDServerRow commonPrepare (JDSQLStatement sqlStatement) // private protected
        throws SQLException
    {
        cancelled_ = false;

		connection_.checkAccess (sqlStatement);
        JDServerRow resultRow = null;
        nameOverride_ = "";

        // Check for DRDA connect or disconnect.  @B1A
        if (sqlStatement.isDRDAConnect ()) {
            connection_.setDRDA (true);     

            // It is possible at this point, that current statement
            // id does not follow the DRDA rules (defined in 
            // AS400JDBCConnection.getUnusedId()), but we will not
            // work around that at this point.  This simple workaround
            // is to create a new Statement immediately after connecting.
        }
        else if (sqlStatement.isDRDADisconnect ())
            connection_.setDRDA (false);

        // Create the SQL package if necessary.
        if (! packageManager_.isCreated())
            packageManager_.create ();

        // There are three distinct cases. Exactly one of these
        // branches will be taken.

        // CASE 1: The statement appears in the cached package.
        //
        // If the SQL package is cached, check to see if this SQL
        // statement is in there.  If so, then gather data accordingly
        // and skip the prepare.
        //
        if (packageManager_.isCached()) {
            if (sqlStatement.isPackaged()) {
                int i = packageManager_.getCachedStatementIndex (sqlStatement);
                if (i != -1) {

                    // Gather results from package cache.
                    DBDataFormat dataFormat = packageManager_.getCachedDataFormat (i);
                    if (dataFormat == null)
                        resultRow = null;
                    else
                        resultRow = new JDServerRow (connection_, id_,
                            dataFormat, settings_);

                    commonPrepareBypass (sqlStatement, i);

                    nameOverride_ = packageManager_.getCachedStatementName (i);

                    // Output a summary as a trace message.
                    if (JDTrace.isTraceOn())
                        JDTrace.logInformation (this,
                            "Statement [" + sqlStatement + "] was found "
                            + "in the cached package as " + nameOverride_);
                }
            }
        }

        // If the SQL package is not cached, then we must prepare
        // the statement on the server.
        if (nameOverride_.length() == 0) {

            // @E7A - start
            //
            // CASE 2a: Statement is a DRDA CONNECT.
            //
            if (sqlStatement.getNativeType() == JDSQLStatement.TYPE_CONNECT) {

                // Sync up the RPB.
                syncRPB();

        		try {

	        		DBSQLRequestDS request = new DBSQLRequestDS (
		        	    DBSQLRequestDS.FUNCTIONID_CONNECT, id_,
			            DBSQLRequestDS.ORS_BITMAP_RETURN_DATA
			            + DBSQLRequestDS.ORS_BITMAP_SQLCA, 0);

        			request.setStatementText (sqlStatement.toString (), connection_.getConverter(AS400JDBCConnection.UNICODE_CCSID_)); // @E3C
	        		request.setStatementType (sqlStatement.getNativeType ());

    		    	if (packageManager_.isEnabled()) {
	    		        if (sqlStatement.isPackaged()) {
              		    	request.setPrepareOption (1);
   			                request.setPackageName (packageManager_.getName (), connection_.getConverter ());
          		        }
          		        else
          		            request.setPrepareOption (0);
              		}
           		    else
       	    	        request.setPrepareOption (0);

                    commonPrepareBefore (sqlStatement, request);
                    commonExecuteBefore (sqlStatement, request);

	        		DBReplyRequestedDS reply = connection_.sendAndReceive (request, id_);

    	    		int errorClass = reply.getErrorClass();
	    	    	int returnCode = reply.getReturnCode();

		    	    if (errorClass != 0) {
                  	    if (returnCode < 0)
                    	    JDError.throwSQLException (connection_, id_, errorClass, returnCode);
                    	else
    	                    postWarning (JDError.getSQLWarning (connection_, id_, errorClass, returnCode));
       	    	    }
                    
                    // Compute the update count and number of results.
                    updateCount_ = 0;
                    numberOfResults_ = 0;

                    commonPrepareAfter (sqlStatement, reply);
                    commonExecuteAfter (sqlStatement, reply);
                }
		        catch (DBDataStreamException e) {
			        JDError.throwSQLException (JDError.EXC_INTERNAL, e);
        		}

                // Inform the transaction manager that a statement
                // was executed.
                transactionManager_.statementExecuted ();

                // Output a summary as a trace message.   The * signifies that the
                // statement name comes from the RPB.
                if (JDTrace.isTraceOn()) {
                    JDTrace.logInformation (this,
                        "Executed connect " + name_ + "* [" + sqlStatement + "]");
                }

            }
            // @E7A - end

            // CASE 2: Statement can be executed immediately.
            //
            // This is essentially the prepare and execute combined
            // in one datastream.  We will then be able to skip the
            // execute step later.
            //
            else if ((allowImmediate_) && (sqlStatement.isImmediatelyExecutable ())) {  // @E7C

                // Sync up the RPB.
                syncRPB ();

        		try {

	        		DBSQLRequestDS request = new DBSQLRequestDS (
		        	    DBSQLRequestDS.FUNCTIONID_EXECUTE_IMMEDIATE, id_,
			            DBSQLRequestDS.ORS_BITMAP_RETURN_DATA
			            + DBSQLRequestDS.ORS_BITMAP_SQLCA, 0);

        			request.setStatementText (sqlStatement.toString (), connection_.getConverter(AS400JDBCConnection.UNICODE_CCSID_)); // @E3C
	        		request.setStatementType (sqlStatement.getNativeType ());

                    int openAttributes = cursor_.getOpenAttributes (sqlStatement, blockCriteria_);
            		request.setOpenAttributes (openAttributes);

    		    	if (packageManager_.isEnabled()) {
	    		        if (sqlStatement.isPackaged()) {
              		    	request.setPrepareOption (1);
   			                request.setPackageName (packageManager_.getName (), connection_.getConverter ());
          		        }
          		        else
          		            request.setPrepareOption (0);
              		}
           		    else
       	    	        request.setPrepareOption (0);

                    commonPrepareBefore (sqlStatement, request);
                    commonExecuteBefore (sqlStatement, request);

	        		DBReplyRequestedDS reply = connection_.sendAndReceive (request, id_);

    	    		int errorClass = reply.getErrorClass();
	    	    	int returnCode = reply.getReturnCode();

		    	    if (errorClass != 0) {
                  	    if (returnCode < 0)
                    	    JDError.throwSQLException (connection_, id_, errorClass, returnCode);
                    	else
    	                    postWarning (JDError.getSQLWarning (connection_, id_, errorClass, returnCode));
       	    	    }
                    
                    transactionManager_.processCommitOnReturn(reply);           // @E2A

                    // Compute the update count.
                    DBReplySQLCA sqlca = reply.getSQLCA ();
                    updateCount_ = sqlca.getErrd3 ();
                    rowCountEstimate_ = -1;                                     // @ECA

                    // Compute the number of results.
                    boolean isCall = (sqlStatement.getNativeType () == JDSQLStatement.TYPE_CALL);
                    if (/*(numberOfResults_ == 0) && */(isCall))
                        numberOfResults_ = sqlca.getErrd2 ();
                    else
                        numberOfResults_ = 0;

                    // If this is a CALL and result sets came back, but
                    // no format was returned, then open the cursor.  The result
                    // set must be forward only and read only.
                    // This is a server restriction.                                    @EBA
                    if ((isCall == true) && (numberOfResults_ > 0)) {
                        JDServerRow row = new JDServerRow (connection_, id_,
                            cursor_.openDescribe (openAttributes, false),
                            settings_);
                        JDServerRowCache rowCache = new JDServerRowCache (
                            row, connection_, id_, getBlockingFactor (
                            sqlStatement, row.getRowLength()));
                        resultSet_ = new AS400JDBCResultSet (this,
                            sqlStatement, rowCache,
                            connection_.getCatalog(), cursor_.getName(),
                            maxRows_, ResultSet.TYPE_FORWARD_ONLY,
                            ResultSet.CONCUR_READ_ONLY,
                            fetchDirection_, fetchSize_);
                        if (resultSet_.getConcurrency () != resultSetConcurrency_)
                            postWarning (JDError.getSQLWarning (JDError.WARN_OPTION_VALUE_CHANGED));
                    }

                    commonPrepareAfter (sqlStatement, reply);
                    commonExecuteAfter (sqlStatement, reply);
                }
		        catch (DBDataStreamException e) {
			        JDError.throwSQLException (JDError.EXC_INTERNAL, e);
        		}

                // Inform the transaction manager that a statement
                // was executed.
                transactionManager_.statementExecuted ();

                // Output a summary as a trace message.   The * signifies that the
                // statement name comes from the RPB.
                if (JDTrace.isTraceOn()) {
                    JDTrace.logInformation (this,
                        "Executed immediately " + name_ + "* [" + sqlStatement + "]");
                    JDTrace.logInformation (this,
                        "Update count = " + updateCount_);
                    JDTrace.logInformation (this,
                        "Result set = " + (resultSet_ != null));
                    JDTrace.logInformation (this,
                        "Number of result sets = " + numberOfResults_);
                }

            }

            // CASE 3: Normal prepare.
            //
            else {

                // Sync up the RPB.
                syncRPB ();

        		try {

	        		DBSQLRequestDS request = new DBSQLRequestDS (
		        	    DBSQLRequestDS.FUNCTIONID_PREPARE_DESCRIBE, id_,
			            DBSQLRequestDS.ORS_BITMAP_RETURN_DATA
			            + DBSQLRequestDS.ORS_BITMAP_DATA_FORMAT, 0);

        			request.setStatementText (sqlStatement.toString (), connection_.getConverter(AS400JDBCConnection.UNICODE_CCSID_)); // @E3C
	        		request.setStatementType (sqlStatement.getNativeType ());

    		    	if (packageManager_.isEnabled()) {
	    		        if (sqlStatement.isPackaged()) {
              		    	request.setPrepareOption (1);
   			                request.setPackageName (packageManager_.getName (), connection_.getConverter ());
          		        }
          		        else
          		            request.setPrepareOption (0);
              		}
           		    else
       	    	        request.setPrepareOption (0);

                    commonPrepareBefore (sqlStatement, request);

	        		DBReplyRequestedDS reply = connection_.sendAndReceive (request, id_);

    	    		int errorClass = reply.getErrorClass();
	    	    	int returnCode = reply.getReturnCode();

		    	    if (errorClass != 0) {
                  	    if (returnCode < 0)
                    	    JDError.throwSQLException (connection_, id_, errorClass, returnCode);
                    	else
    	                    postWarning (JDError.getSQLWarning (connection_, id_, errorClass, returnCode));
       	    	    }

                    // Gather results from the reply.
                    DBDataFormat dataFormat = reply.getDataFormat ();
                    if (dataFormat == null)
                        resultRow = null;
                    else
                        resultRow = new JDServerRow (connection_, id_,
                            dataFormat, settings_);

                    commonPrepareAfter (sqlStatement, reply);
                }
		        catch (DBDataStreamException e) {
			        JDError.throwSQLException (JDError.EXC_INTERNAL, e);
        		}

                // Output a summary as a trace message.  The * signifies that the
                // statement name comes from the RPB.
                if (JDTrace.isTraceOn())
                    JDTrace.logInformation (this,
                        "Prepared " + name_ + "* [" + sqlStatement + "]");
            }

    	}

        // Check to see if the statement was cancelled.
        if (cancelled_)
            JDError.throwSQLException (JDError.EXC_OPERATION_CANCELLED);

        // If any of the fields is a locator, then we need to turn off             @B2A
        // record blocking.                                                        @B2A
        lastPrepareContainsLocator_ = false;                                    // @B2A
        if (resultRow != null) {                                                // @B2A
            int fieldCount = resultRow.getFieldCount ();                        // @B2A
            for (int i = 1; i <= fieldCount; ++i) {                             // @B2A
                if (resultRow.getSQLData (i) instanceof SQLLocator)             // @B2A
                    lastPrepareContainsLocator_ = true;                         // @B2A
            }                                                                   // @B2A
        }                                                                       // @B2A

		return resultRow;
    }



/**
Performs common operations needed after a prepare.

@param  sqlStatement    The SQL statement.
@param  reply           The prepare reply.

@exception      SQLException    If an error occurs.
**/
//
// This method is intended to be overriden, if needed.
//
    void commonPrepareAfter (JDSQLStatement sqlStatement,
                             DBReplyRequestedDS reply) // private protected
        throws SQLException
    {
        // Nothing.
    }



/**
Performs common operations needed before a prepare.

@param  sqlStatement    The SQL statement.
@param  request         The prepare request.

@exception      SQLException    If an error occurs.
**/
//
// This method is intended to be overriden, if needed.
//
    void commonPrepareBefore (JDSQLStatement sqlStatement,
                              DBSQLRequestDS request) // private protected
        throws SQLException
    {
        // Close the result set before preparing another.
		closeResultSet (JDCursor.REUSE_YES);
    }



/**
Performs common operations in leiu of a prepare.

@param  sqlStatement    The SQL statement.
@param  statementIndex  The cached statement index.

@exception      SQLException    If an error occurs.
**/
//
// This method is intended to be overriden, if needed.
//
    void commonPrepareBypass (JDSQLStatement sqlStatement,
                              int statementIndex) // private protected
        throws SQLException
    {
        // Nothing.
    }



/**
Runs an SQL statement that may return multiple result sets.
This closes the current result set and clears warnings before 
executing the new SQL statement.

<p>Under some situations, a single SQL statement may return
multiple result sets, an update count, or both.  This might occur
when executing a stored procedure that returns multiple
result sets or when dynamically executing an unknown SQL string.

<p>Use getMoreResults(), getResultSet(), and getUpdateCount()
to navigate through multiple result sets, an update count, or
both.

@param  sql     The SQL statement.
@return         true if a result set was returned, false
                if an update count was returned or nothing
                was returned.

@exception      SQLException    If the statement is not open,
                                the SQL statement contains a syntax
                                error, the query timeout limit is
                                exceeded, or an error occurs.
**/
    public boolean execute (String sql)
      throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
    		JDSQLStatement sqlStatement = new JDSQLStatement (sql,
    		    settings_.getDecimalSeparator (), escapeProcessing_,
    		    packageCriteria_);            // @A1A
            
            if (JDTrace.isTraceOn())                                                    // @D0A
                JDTrace.logInformation (this, "Executing [" + sqlStatement + "]");      // @D0A
    
            // Validate that no parameters are set, since parameters
            // imply the need for a PreparedStatement.
            if (sqlStatement.countParameters () > 0)
                JDError.throwSQLException (JDError.EXC_PARAMETER_COUNT_MISMATCH);
    
            // Prepare and execute.
            JDServerRow resultRow = commonPrepare (sqlStatement);
            commonExecute (sqlStatement, resultRow);
    
     		return (resultSet_ != null);
        }
    }



// JDBC 2.0
/**
Runs the batch of SQL statements.  Batch updates can be used
to submit a set of SQL statements together as a single unit.
The SQL statements are run in the order in which they were
added to the batch.  The batch is cleared after the SQL statements
are run.  In addition, this closes the current result set and
clears warnings before executing the new SQL statement.

<p>When batch updates are run, autocommit should usually be turned off.
This allows the caller to decide whether or not to commit the
transaction in the event that an error occurs and some of the
SQL statements in a batch fail to run.

@return An array of row counts for the SQL statements that are run.
        The array contains one element for each statement in the
        batch of SQL statements.  The array is ordered according to
        the order in which the SQL statements were added to the batch.

@exception SQLException If the statement is not open,
                        an SQL statement contains a syntax
                        error, the query timeout limit is
                        exceeded, an SQL statement returns
                        a result set, or an error occurs.
**/
//
// Implementation notes:
//
// 1.  We are using a Vector as the main data structure.
//     Vector is supposedly synchronized already, so we
//     should not have to worry about synchronization.
//
    public int[] executeBatch ()
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
            int batchSize = batch_.size ();
            int[] updateCounts = new int[batchSize];
    
            int i = 0;
            try {
                Enumeration enum = batch_.elements ();
                while (enum.hasMoreElements ()) {
    
                    // Prepare and execute.  Check for a result set in
                    // both places.  It is best to catch it after the
                    // prepare (so we don't open a cursor), but with
                    // some stored procedures, we can't catch it until
                    // the execute.
                    JDSQLStatement sqlStatement = (JDSQLStatement) enum.nextElement ();
    
                    if (JDTrace.isTraceOn())                                                               // @D0A
                        JDTrace.logInformation (this, "Executing from batch [" + sqlStatement + "]");      // @D0A
    
                    JDServerRow resultRow = commonPrepare (sqlStatement);
                    if (resultRow != null)
                        JDError.throwSQLException (JDError.EXC_CURSOR_STATE_INVALID);
    
                    commonExecute (sqlStatement, resultRow);
                    if (resultSet_ != null) {
                        closeResultSet (JDCursor.REUSE_YES);
                        JDError.throwSQLException (JDError.EXC_CURSOR_STATE_INVALID);
                    }
    
                    updateCounts[i++] = updateCount_;
                }
            }
            catch (SQLException e) {
    
                // The specification says that if we get an error,
                // then the size of the update counts array should
                // reflect the number of statements that were
                // executed without error.
                int[] updateCounts2 = new int[i];
                System.arraycopy (updateCounts, 0, updateCounts2, 0, i);
    
                batch_.removeAllElements ();
                throw new BatchUpdateException (e.getMessage (),
                    e.getSQLState (), e.getErrorCode (), updateCounts2);
            }
    
            batch_.removeAllElements ();
            return updateCounts;
        }
    }



/**
Runs an SQL statement that returns a single result set.
This closes the current result set and clears warnings 
before executing the new SQL statement.

@param  sql     The SQL statement.
@return         The result set that contains the data produced
                by the query.

@exception      SQLException    If the statement is not open,
                                the SQL statement contains a syntax
                                error, no result set is returned by the
                                database, the query timeout limit is
                                exceeded, or an error occurs.
**/
    public ResultSet executeQuery (String sql)
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
    		JDSQLStatement sqlStatement = new JDSQLStatement (sql,
    		    settings_.getDecimalSeparator (), escapeProcessing_,
    		    packageCriteria_);                                      // @A1A
    
            if (JDTrace.isTraceOn())                                                          // @D0A
                JDTrace.logInformation (this, "Executing query [" + sqlStatement + "]");      // @D0A
    
            // Validate that no parameters are set, since parameters
            // imply the need for a PreparedStatement.
            if (sqlStatement.countParameters () > 0)
                JDError.throwSQLException (JDError.EXC_PARAMETER_COUNT_MISMATCH);
    
            // Prepare and execute.
            JDServerRow resultRow = commonPrepare (sqlStatement);
            commonExecute (sqlStatement, resultRow);
    
            if (resultSet_ == null)
                JDError.throwSQLException (JDError.EXC_CURSOR_STATE_INVALID);
     		return resultSet_;
        }
    }



/**
Runs an SQL INSERT, UPDATE, or DELETE statement, or any
SQL statement that does not return a result set.
This closes the current result set and clears warnings 
before executing the new SQL statement.

@param  sql     The SQL statement.
@return         Either the row count for INSERT, UPDATE, or
                DELETE, or 0 for SQL statements that
                return nothing.

@exception      SQLException    If the statement is not open,
                                the SQL statement contains a syntax
                                error, the query timeout limit is
                                exceeded, the statement returns
                                a result set, or an error occurs.
**/
    public int executeUpdate (String sql)
      throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
    		JDSQLStatement sqlStatement = new JDSQLStatement (sql,
    		    settings_.getDecimalSeparator (), escapeProcessing_,
    		    packageCriteria_);                                        // @A1A
    
            if (JDTrace.isTraceOn())                                                           // @D0A
                JDTrace.logInformation (this, "Executing update [" + sqlStatement + "]");      // @D0A
    
            // Validate that no parameters are set, since parameters
            // imply the need for a PreparedStatement.
            if (sqlStatement.countParameters () > 0)
                JDError.throwSQLException (JDError.EXC_PARAMETER_COUNT_MISMATCH);
    
            // Prepare and execute.  Check for a result set in both
            // places.  It is best to catch it after the prepare (so
            // we don't open a cursor), but with some stored procedures,
            // we can't catch it until the execute.
            JDServerRow resultRow = commonPrepare (sqlStatement);
            if (resultRow != null)
                JDError.throwSQLException (JDError.EXC_CURSOR_STATE_INVALID);
    
            commonExecute (sqlStatement, resultRow);
            if (resultSet_ != null) {
                closeResultSet (JDCursor.REUSE_YES);
                JDError.throwSQLException (JDError.EXC_CURSOR_STATE_INVALID);
            }
    
    		return updateCount_;
        }
    }



/**
Closes the statement if not explicitly closed by the caller.

@exception   Throwable      If an error occurs.
**/
    protected void finalize ()
        throws Throwable
    {
        if (! isClosed ())
            close ();
        super.finalize ();
    }



/**
Returns the appropriate blocking factor for the SQL statement.

@param  sqlStatement    The SQL statement.
@param  rowLength       The row length.
@return                 The blocking factor (in rows).
**/
    int getBlockingFactor (JDSQLStatement sqlStatement,
                           int rowLength) // private protected
    {
        boolean block = false;
        boolean useFetchSize = false;

        // Only block if the cursor is not updatable
        // and no locators are in the result set.                                  @B2A
        if ((cursor_.getConcurrency() != ResultSet.CONCUR_UPDATABLE)            // @B2C @EAC
            && (lastPrepareContainsLocator_ == false)) {                        // @B2A

            // Determine if we should block based on the block
            // criteria and SQL statement characteristics.
            if (blockCriteria_.equalsIgnoreCase (JDProperties.BLOCK_CRITERIA_NONE)) {
                block = true;
                useFetchSize = true;
            }

            if (sqlStatement != null) {
                if ((blockCriteria_.equalsIgnoreCase (JDProperties.BLOCK_CRITERIA_IF_FETCH))
                    && (sqlStatement.isForFetchOnly()))
                    block = true;

                else if ((blockCriteria_.equalsIgnoreCase (JDProperties.BLOCK_CRITERIA_UNLESS_UPDATE))
                    && (! sqlStatement.isForUpdate()))
                    block = true;
            }
            else
               if (blockCriteria_.equalsIgnoreCase (JDProperties.BLOCK_CRITERIA_UNLESS_UPDATE))
                    block = true;

        }

        // Compute the blocking factor.
        int blockingFactor;
        if (block) {
            if (useFetchSize)
                blockingFactor = fetchSize_;
            else {
                blockingFactor = (blockSize_ * 1024) / rowLength;
                if (blockingFactor > 32767)
                    blockingFactor = 32767;
                else if (blockingFactor <= 0)
                    blockingFactor = 1;
            }
        }
        else
            blockingFactor = 1;

        return blockingFactor;
    }



// JDBC 2.0
/**
Returns the connection for this statement.

@return The connection for this statement.

@exception SQLException If an error occurs.
**/
    public Connection getConnection ()
        throws SQLException
    {
        return connection_;
    }



/**
Returns the name of the SQL cursor that is used by
subsequent statement execute methods.

@return     The cursor name.
**/
    String getCursorName ()
    {
        synchronized(internalLock_) {                                            // @E6A
		    return cursor_.getName ();
        }
    }



// JDBC 2.0
/**
Returns the fetch direction.

@return The fetch direction.

@exception SQLException If the statement is not open.
**/
    public int getFetchDirection ()
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
		    return fetchDirection_;
        }
    }



// JDBC 2.0
/**
Returns the fetch size.

@return The fetch size.

@exception SQLException If the statement is not open.
**/
    public int getFetchSize ()
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
		    return fetchSize_;
        }
    }



/**
Returns the maximum field size limit for the statement.
The maximum field size limit is the maximum amount of data
returned for any column value.  It applies only to BINARY,
VARBINARY, CHAR, and VARCHAR fields.  If the limit is exceeded,
then the excess data is discarded.

@return     The maximum field size limit (in bytes), or
            0 for no limit.

@exception  SQLException    If the statement is not open.
**/
    public int getMaxFieldSize ()
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
		    return maxFieldSize_;
        }
    }



/**
Returns the maximum rows limit for the statement.
The maximum rows limit is the maximum number of rows that a
result set can contain.  If the limit is exceeded, then the
excess rows are dropped.

@return     The maximum rows limit, or 0 for no limit.

@exception  SQLException    If the statement is not open.
**/
    public int getMaxRows ()
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
		    return maxRows_;
        }
    }



/**
Returns the next result set.  This closes the
current result set.

@return         true if another result set is available, false
                if there are no more result sets.

@exception      SQLException    If an error occurs.
**/
    public boolean getMoreResults ()
      throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            // Initialize.
            cancelled_ = false;
            checkOpen ();
       		closeResultSet (JDCursor.REUSE_RESULT_SET);
    
    		// Determine if there more result sets.
    		if (--numberOfResults_ > 0) {
    
        		// Send the data stream.
    	    	try {
    		    	DBSQLRequestDS request = new DBSQLRequestDS (
    			        DBSQLRequestDS.FUNCTIONID_OPEN_DESCRIBE,
        			    id_, DBSQLRequestDS.ORS_BITMAP_RETURN_DATA
                        + DBSQLRequestDS.ORS_BITMAP_SQLCA
                        + DBSQLRequestDS.ORS_BITMAP_DATA_FORMAT, 0);
    
                    int openAttributes = cursor_.getOpenAttributes(null, blockCriteria_);   // @E1A
            		request.setOpenAttributes(openAttributes);                              // @E1C
    
    		    	DBReplyRequestedDS reply = connection_.sendAndReceive (request, id_);
    
                    // Gather information from the reply.
                    DBReplySQLCA sqlca = reply.getSQLCA ();
                    DBDataFormat dataFormat = reply.getDataFormat ();
    
                    // Check for server errors.
      	    	    int errorClass = reply.getErrorClass();
       	            int returnCode = reply.getReturnCode();
    
                    if (errorClass != 0) {
              	        if (returnCode < 0)
                	        JDError.throwSQLException (connection_, id_, errorClass, returnCode);
                    	else
            	            postWarning (JDError.getSQLWarning (connection_, id_, errorClass, returnCode));
       	        	}
    
                    // Process a potential cursor conecurrency override.                             @E1A @EAC
                    cursor_.processConcurrencyOverride(openAttributes, reply);                    // @E1A @EAC
    
                    // Note that the cursor was opened.
                    cursor_.setState (false);
    
                    // Compute the result set.
                    JDServerRow row = new JDServerRow (connection_, id_, dataFormat,
                        settings_);
                    JDServerRowCache rowCache = new JDServerRowCache (
                        row, connection_, id_, getBlockingFactor (
                        null, row.getRowLength()));
    
                    // If the result set concurrency is updatable, check to                            @E1C
                    // see if the server overrode the cursor type to read only.                        @E1C
                    // Don't worry about the other direction (server overrides                         @E1C
                    // from read-only to updatable).                                                   @E1C
                    int actualConcurrency = (resultSetConcurrency_ == ResultSet.CONCUR_UPDATABLE)   // @E1C
                        ? cursor_.getConcurrency() : resultSetConcurrency_;                         // @E1C @EAC
    
                    resultSet_ = new AS400JDBCResultSet (this, null,
                        rowCache, connection_.getCatalog(),
                        cursor_.getName(), maxRows_, resultSetType_,
                        actualConcurrency, fetchDirection_,
                        fetchSize_);                                                                // @ECC
                    if (resultSet_.getConcurrency () != resultSetConcurrency_)
                        postWarning (JDError.getSQLWarning (JDError.WARN_OPTION_VALUE_CHANGED));
                }
    	    	catch (DBDataStreamException e) {
    		    	JDError.throwSQLException (JDError.EXC_INTERNAL, e);
        		}
            }
    
            // Check to see if the statement was cancelled.
            if (cancelled_)
                JDError.throwSQLException (JDError.EXC_OPERATION_CANCELLED);
    
            // @A0A
            // Added code to set updateCount_ = -1.
    	    updateCount_ = -1;                                            // @A0A
    
            return (resultSet_ != null);
        }
    }



/**
Returns the query timeout limit for this statement.
The query timeout limit is the number of seconds that the
driver will wait for an SQL statement to execute.

@return     The query timeout limit (in seconds), or
            0 for no limit.

@exception  SQLException    If the statement is not open.
**/
    public int getQueryTimeout ()
      throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
           checkOpen ();
		   return queryTimeout_;
        }
    }



/**
Returns the current result set.

@return     The current result set, or null if an update
            count was returned or there are no more
            result sets.

@exception  SQLException    If the statement is not open.
**/
    public ResultSet getResultSet ()
      throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
		    return resultSet_;
        }
    }



// JDBC 2.0
/**
Returns the result set concurrency to be used for this statement.

@return The result set concurrency.

@exception  SQLException    If the statement is not open.
**/
    public int getResultSetConcurrency ()
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
            return resultSetConcurrency_;
        }
    }



// JDBC 2.0
/**
Returns the result set type to be used for this statement.

@return The result set type.

@exception  SQLException    If the statement is not open.
**/
    public int getResultSetType ()
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
            return resultSetType_;
        }
    }



/**
Returns the current update count.

@return     The update count, or -1 if a result set was
            returned or there are no more result sets.

@exception  SQLException    If the statement is not open.
**/
    public int getUpdateCount ()
      throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
		    return (resultSet_ != null) ? -1 : updateCount_;
        }
    }



/**
Returns the first warning reported for the statement.
Subsequent warnings may be chained to this warning.

@return     The first warning, or null if no warnings
            have been reported.

@exception  SQLException    If an error occurs.
**/
    public SQLWarning getWarnings ()
      throws SQLException
    {
		return sqlWarning_;
    }



/**
Indicates if the statement is closed.

@return     true if the statement is closed;
            false otherwise.
**/
    boolean isClosed ()
    {
		return closed_;
    }




// @B3A
/**
Marks the cursor as closed.
**/
    void markCursorClosed()
    {
        cursor_.setState(true);
    }




/**
Notifies the statement that its result set has been closed.

@exception  SQLException    If an error occurs.
**/
    void notifyClose ()
        throws SQLException
    {
        // The result set is close, so we can close the cursor.
		if (! cursor_.isClosed ()) {
		    if (numberOfResults_ > 1)
		        cursor_.close (JDCursor.REUSE_RESULT_SET);
		    else
            	cursor_.close (JDCursor.REUSE_YES);
        }
    }



/**
Posts a warning for the statement.

@param   sqlWarning  The warning.
**/
	void postWarning (SQLWarning sqlWarning)
    {
		if (sqlWarning_ == null)
			sqlWarning_ = sqlWarning;
		else
			sqlWarning_.setNextWarning (sqlWarning);
    }



// @E9C
/**
Sets the SQL cursor name that will be used by the statement.
Cursor names must be unique within the connection.
The cursor name can only be set when no result set is open.

<p>The cursor name can be used in SQL positioned UPDATE or DELETE
statements to identify the current row in the result set generated
by this statement.  By definition, SQL positioned UPDATEs or
DELETEs must be executed by a different statement than the one
that generated the result set being used for positioning.

<p>Cursor names are case sensitive.  However, when using a cursor
name within other SQL positioned UPDATE or DELETE statements,
the cursor name will be uppercased.  If you use a cursor name
with lowercase characters, you need to enclose it in double
quotes when referring to it in other SQL statements.

@param  cursorName    The cursor name.  If null, a unique
                      default name will be used.

@exception      SQLException    If the statement is not open,
                                a result set is open, the cursor
                                name is not unique within the
                                connection, or an error occurs.
**/
//
// Implementation note:
//
// If you set the cursor name to a mixed case string, and then
// later refer to it in an SQL statement, SQL will choke because it
// will have uppercased the string.
//
// At first I thought we should always uppercase, the cursor name
// but that limits callers.  The better solution is to have the callers
// surround mixed case cursor names in SQL statements with double
// quotes.
//
    public void setCursorName (String cursorName)
      throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
    
            // Check that no cursor is open for this statement.
            // We can not just check the cursor, because if the
            // caller closes the result set, we do not close the
            // cursor right away.
            if (resultSet_ != null) {
                if (! resultSet_.isClosed ())
                    JDError.throwSQLException (JDError.EXC_CURSOR_STATE_INVALID);
                else
                    closeResultSet (JDCursor.REUSE_YES);
            }
    
            // If name is null, then use the default name.
            if (cursorName == null)
                cursorName = cursorDefaultName_;
    
            // Validate the length of the cursor name.
            int cursorNameLength = cursorName.length();                                     // @EEA
            if ((cursorNameLength > MAX_CURSOR_NAME_LENGTH) || (cursorNameLength == 0))     // @EEC
                JDError.throwSQLException (JDError.EXC_CURSOR_NAME_INVALID);
    
            // If the name is the same as the current cursor name,
            // then nothing needs to be done.  (If we go through
            // with the change and the cursor name is the same, it
            // will get flagged as ambiguous).
            if (! cursorName.equals (cursor_.getName ())) {
    
                // Check that the cursor name is unique within the
                // connection.
                if (connection_.isCursorNameUsed (cursorName))
                    JDError.throwSQLException (JDError.EXC_CURSOR_NAME_AMBIGUOUS);
    
                cursor_.setName (cursorName);
    
                // Since we store the cursor name in the RPB, we need
                // to sync it after a change.
                rpbSyncNeeded_ = true;
    
            }
        }
    }



/**
Sets the escape processing mode.  When processing escape
clauses, the JDBC driver substitutes escape clauses
in SQL statements with DB2 for OS/400 SQL grammar elements.
If escape processing is not needed, then setting the escape
processing mode to false improves performance.

@param  escapeProcessing      true to process escape clauses;
                              false otherwise.  The default
                              is true.

@exception          SQLException    If the statement is not open.
**/
    public void setEscapeProcessing (boolean escapeProcessing)
      throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
    		escapeProcessing_ = escapeProcessing;
    
            if (JDTrace.isTraceOn())
                JDTrace.logProperty (this, "Escape processing", escapeProcessing_);
        }
    }



// JDBC 2.0
/**
Sets the direction in which the rows in a result set will be
processed.

<p>This setting is not used.

@param      fetchDirection  The fetch direction for processing rows.
                            Valid values are:
                            <ul>
                              <li>ResultSet.FETCH_FORWARD
                              <li>ResultSet.FETCH_REVERSE
                              <li>ResultSet.FETCH_UNKNOWN
                            </ul>
                            The default is ResultSet.FETCH_FORWARD.

@exception          SQLException    If the statement is not open,
                                    the result set type is
                                    ResultSet.TYPE_FORWARD_ONLY,
                                    and the input value is not
                                    ResultSet.FETCH_FORWARD,
                                    or the input value is not valid.
**/
    public void setFetchDirection (int fetchDirection)
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            if (((fetchDirection != ResultSet.FETCH_FORWARD)
                 && (fetchDirection != ResultSet.FETCH_REVERSE)
                 && (fetchDirection != ResultSet.FETCH_UNKNOWN))
                || ((resultSetType_ == ResultSet.TYPE_FORWARD_ONLY)
                    && (fetchDirection != ResultSet.FETCH_FORWARD)))
                JDError.throwSQLException (JDError.EXC_ATTRIBUTE_VALUE_INVALID);
    
            checkOpen ();
    		fetchDirection_ = fetchDirection;
    
            if (JDTrace.isTraceOn())
                JDTrace.logProperty (this, "Fetch direction", fetchDirection_);
        }
    }



// JDBC 2.0
/**
Sets the number of rows to be fetched from the database when more
rows are needed.  The number of rows specified only affects result
sets created using this statement. If the value specified is zero,
then the driver will choose an appropriate fetch size.

<p>This setting only affects statements that meet the criteria
specified in the "block criteria" property.  The fetch size
is only used if the "block size" property is set to "0".

@param fetchSize    The number of rows.  This must be greater than
                    or equal to 0 and less than or equal to the
                    maximum rows limit. The default is zero.

@exception          SQLException    If the statement is not open
                                    or the input value is not valid.
**/
    public void setFetchSize (int fetchSize)
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            if ((fetchSize < 0)
                || ((fetchSize > maxRows_) && (maxRows_ > 0)))
                JDError.throwSQLException (JDError.EXC_ATTRIBUTE_VALUE_INVALID);
    
            checkOpen ();
    		fetchSize_ = fetchSize;
    
            if (JDTrace.isTraceOn())
                JDTrace.logProperty (this, "Fetch size", fetchSize_);
        }
    }



/**
Sets the maximum field size limit.  The maximum field size
limit is the maximum amount of data returned for any column
value.  It applies only to BINARY, VARBINARY, CHAR, and VARCHAR
fields.  If the limit is exceeded, then the excess data is
discarded.

@param  maxFieldSize     The maximum field size limit (in bytes) or
                         0 for no limit. The default is 0.

@exception      SQLException    If the statement is not open
                                or the input value is not valid.
**/
    public void setMaxFieldSize (int maxFieldSize)
      throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
    
            // Validate the argument.
            if (maxFieldSize < 0)
                JDError.throwSQLException (JDError.EXC_ATTRIBUTE_VALUE_INVALID);
    
            maxFieldSize_ = maxFieldSize;
            settings_.setMaxFieldSize (maxFieldSize_);
    
            if (JDTrace.isTraceOn())
                JDTrace.logProperty (this, "Max field size", maxFieldSize_);
        }
    }



/**
Sets the maximum rows limit.  The maximum rows limit is the
maximum number of rows that a result set can contain.
If the limit is exceeded, the excess rows are dropped.


@param  maxRows     The maximum rows limit or 0 for no limit.
                    The default is 0.

@exception      SQLException    If the statement is not open
                                or the input value is not valid.
**/
//
// Implementation note:
//
// We had a debate about what this means with respect to scrollable
// result sets.  Does it limit the number of rows in the result set,
// or the number of rows fetched.  I.e., if you set the max rows to
// 50, can you successfully do absolute(51)?  It is only fetching
// 1 row.  The answer came back from the JavaSoft people that it
// does indeed limit the number of rows in the result set, not
// necessarily the number of fetches.
//
    public void setMaxRows (int maxRows)
      throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
    
            // Validate the argument.
            if (maxRows < 0)
                JDError.throwSQLException (JDError.EXC_ATTRIBUTE_VALUE_INVALID);
    
    		maxRows_ = maxRows;
    
            if (JDTrace.isTraceOn())
                JDTrace.logProperty (this, "Max rows", maxRows_);
        }
    }



/**
Sets the query timeout limit.  The query timeout limit
is the number of seconds that the driver will wait for a
SQL statement to execute.

@param  queryTimeout    The query timeout limit (in seconds)
                        or 0 for no limit.  The default is 0.

@exception      SQLException    If the statement is not open
                                or the input value is not valid.
**/
    public void setQueryTimeout (int queryTimeout)
        throws SQLException
    {
        synchronized(internalLock_) {                                            // @E6A
            checkOpen ();
    
            // Validate the argument.
            if (queryTimeout < 0)
                JDError.throwSQLException (JDError.EXC_ATTRIBUTE_VALUE_INVALID);
    
            if (queryTimeout_ != queryTimeout) {
                queryTimeout_ = queryTimeout;
    
                // Since we store the query timeout in the RPB, we need
                // to sync it after a change.
                rpbSyncNeeded_ = true;
            }
    
            if (JDTrace.isTraceOn())
                JDTrace.logProperty (this, "Query timeout", queryTimeout_);
        }
    }



/**
Creates or changes the RPB (Request Parameter Block) for the
statement.

@exception  SQLException    If an error occurs.
**/
    private void syncRPB ()
        throws SQLException
    {
        if (rpbSyncNeeded_) {

            int functionId = rpbCreated_ ? DBSQLRPBDS.FUNCTIONID_CHANGE_RPB
                : DBSQLRPBDS.FUNCTIONID_CREATE_RPB;

       	    try {
    		    DBSQLRPBDS request = new DBSQLRPBDS (functionId, id_, 0, 0);
   	    		request.setPrepareStatementName (name_, connection_.getConverter ());
   		        request.setCursorName (cursor_.getName (), connection_.getConverter ());
  		    	if (packageManager_.isEnabled())
   			        request.setLibraryName (packageManager_.getLibraryName (), connection_.getConverter ());
   			    if (queryTimeout_ > 0)
       			    request.setQueryTimeout (queryTimeout_);
       			else
       			    request.setQueryTimeout (-1);
    	        connection_.send (request, id_);
	        }
   		    catch (DBDataStreamException e) {
    		    JDError.throwSQLException (JDError.EXC_INTERNAL, e);
    	    }

	        rpbCreated_ = true;
	        rpbSyncNeeded_ = false;
	    }
	}



/**
Returns the statement name.

@return     The statement name.
**/
    public String toString ()
    {
        return name_;
    }



}
