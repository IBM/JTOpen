///////////////////////////////////////////////////////////////////////////////
//                                                                             
// JTOpen (IBM Toolbox for Java - OSS version)                                 
//                                                                             
// Filename: AS400.java
//                                                                             
// The source code contained herein is licensed under the IBM Public License   
// Version 1.0, which has been approved by the Open Source Initiative.         
// Copyright (C) 1997-2001 International Business Machines Corporation and     
// others. All rights reserved.                                                
//                                                                             
///////////////////////////////////////////////////////////////////////////////

package com.ibm.as400.micro;

import java.io.*;

/**
 *  The SQLResultSet class represents the results of executing an SQL statement.  This class provides access 
 *  to a result set of data generated by a SQLStatement from a wireless device.  This class provides a modified subset 
 *  of the JDBC functions available in the com.ibm.as400.access package.
 *
 *  <P>The following example demonstrates the use of SQLResultSet:
 *  <br>
 *  <pre>
 *   AS400 system = new AS400("mySystem", "myUserid", "myPwd", "myMEServer");
 *   try
 *   {
 *       // Create a hashtable containing any SQL connection properties.
 *       Hashtable properties = new Hashtable();
 *       properties.put("package cache", "true");
 *       properties.put("trace", "true");
 
 *       // Execute an SQL statement.
 *       SQLResultSet rs = SQLStatement.executeQuery(system, properties, "select * from qiws.qcustcdt");
 *       
 *       // Get the row data.
 *       String[] columns = rs.getRowData();
 *       
 *       // While there are more rows, continue to call next() and
 *       // print out the selected columns.
 *       while (rs.next())
 *       {
 *           System.out.println(columns[2]+" "+columns[3]);
 *           columns = rs.getRowData();
 *       }
 *       
 *       // Close the result set.
 *       rs.close();
 *   }
 *   catch (Exception e)
 *   {
 *       // Handle the exception
 *   }
 *   // Done with the system object.
 *   system.disconnect();
 *  </pre>
 **/
public final class SQLResultSet
{
    private AS400 system_ = null;
    private int transactionID_ = -1;


    /**
     *  Construct a SQLResultSet object.
     **/
    private SQLResultSet()
    {
    }


    /**
     *  Construct a SQLResultSet object with the specified <i>system</i> and transaction <i>id</i>.
     **/
    SQLResultSet(AS400 system, int id)
    {
        system_ = system;
        transactionID_ = id;
    }


    /**
     *  Positions the cursor to an absolute row number. 
     *
     *  @param rowNumber - The absolute row number. If the absolute row number is positive, this positions
     *                                  the cursor with respect to the beginning of the result set. If the absolute row number is negative,
     *                                  this positions the cursor with respect to the end of result set.
     *
     *  @return true if the requested cursor position is valid; false otherwise.
     *
     *  @exception  IOException  If an error occurs while communicating with the server.
     *  @exception  MEException  If an error occurs while processing the ToolboxME request.
     **/
    public boolean absolute(int rowNumber) throws IOException, MEException
    {
        return positionCursor(MEConstants.SQL_ABSOLUTE, rowNumber);
    }


    /**
     *  Close the SQLResultSet.
     *
     *  @exception  IOException  If an error occurs while communicating with the iSeries server.
     *  @exception  MEException  If an error occurs while processing the ToolboxME request.
     **/
    public void close() throws IOException, MEException
    {
        if (system_ == null)
            return;

        synchronized(system_)
        {
            system_.toServer_.writeInt(MEConstants.SQL_CLOSE);
            system_.toServer_.writeInt(transactionID_);
            system_.toServer_.flush();

            int retVal = system_.fromServer_.readInt();

            if (retVal != MEConstants.SQL_RESULT_SET_CLOSED)
                throw new MEException(system_.fromServer_.readUTF(), retVal);

            system_ = null; // Invalidate this result set object.
        }
    }


    /**
     *  Positions the cursor to the first row
     *
     *  @return true if the requested cursor position is valid; false otherwise.
     *
     *  @exception  IOException  If an error occurs while communicating with the iSeries server.
     *  @exception  MEException  If an error occurs while processing the ToolboxME request.
     **/
    public boolean first() throws IOException, MEException
    {
        return positionCursor(MEConstants.SQL_FIRST, -1);
    }


    /**
     *  Returns the current row number, or 0. 
     *
     *  0 is returned if the cursor is not on a valid row (such as before the first row, after the last row, or on the
     *  insert row), or if the result set is empty.     
     *
     *  @return The current row number (1-based), or 0 if the current row is not valid.
     *
     *  @exception  IOException  If an error occurs while communicating with the server.
     *  @exception  MEException  If an error occurs while processing the ToolboxME request.
     **/
    public int getRowNumber() throws IOException, MEException
    {    
        if (system_ == null)
           throw new MEException("Result set is closed.", MEException.RESULT_SET_CLOSED);

       synchronized(system_)
       {
           system_.toServer_.writeInt(MEConstants.SQL_ROW_NUMBER);
           system_.toServer_.writeInt(transactionID_);
           system_.toServer_.flush();

           int retVal = system_.fromServer_.readInt();

           // If a -1 was received an exception occurred; otherwise return the row number.
           if (retVal == -1)
               throw new MEException(system_.fromServer_.readUTF(), retVal);
           else
               return retVal;
       }
    }


    /**
     *  Returns the data in the current row
     *
     *  @return The column data for the row.  Null will be returned if the row is empty.
     *
     *  @exception  IOException  If an error occurs while communicating with the server.
     *  @exception  MEException  If an error occurs while processing the ToolboxME request.
     **/
    public String[] getRowData() throws IOException, MEException
    {
        if (system_ == null)
            throw new MEException("Result set is closed.", MEException.RESULT_SET_CLOSED);

        synchronized(system_)
        {
            system_.toServer_.writeInt(MEConstants.SQL_ROW_DATA);
            system_.toServer_.writeInt(transactionID_);
            system_.toServer_.flush();

            int retVal = system_.fromServer_.readInt();

            if (retVal == MEConstants.SQL_REQUEST_FAILED)
            {
                return null;
            }
            else if (retVal == MEConstants.SQL_REQUEST_SUCCESSFUL)
            {
                int numFields = system_.fromServer_.readInt();
                
                String[] fields = new String[numFields];
                
                for (int i=0; i<fields.length; ++i)
                {
                    fields[i] = system_.fromServer_.readUTF();
                }
                
                return fields;
            }
            else
            {
                throw new MEException(system_.fromServer_.readUTF(), retVal);
            }
        }
    }
    
    
    /**
     *  Positions the cursor to the last row
     *
     *  @return true if the requested cursor position is valid; false otherwise.
     *
     *  @exception  IOException  If an error occurs while communicating with the server.
     *  @exception  MEException  If an error occurs while processing the ToolboxME request.
     **/
    public boolean last() throws IOException, MEException
    {
        return positionCursor(MEConstants.SQL_LAST, -1);
    }



    /**
     *  Positions the cursor to the next row. 
     *
     *  @return true if the requested cursor position is valid; false otherwise.
     *
     *  @exception  IOException  If an error occurs while communicating with the server.
     *  @exception  MEException  If an error occurs while processing the ToolboxME request.
     **/
    public boolean next() throws IOException, MEException
    {
        return positionCursor(MEConstants.SQL_NEXT, -1);
    }

    
    /**
     *  Positions the cursor to the previous row.
     *
     *  @return true if the requested cursor position is valid; false otherwise.
     *
     *  @exception  IOException  If an error occurs while communicating with the server.
     *  @exception  MEException  If an error occurs while processing the ToolboxME request.
     **/
    public boolean previous() throws IOException, MEException
    {
        return positionCursor(MEConstants.SQL_PREVIOUS, -1);
    }


    /**
     *  Position the cursor based on the requested action.  The
     *  actions can be firstnext, previous, or absolute.
     *
     *  @param action The cursor position.
     *  @param rowNumber The row number.  -1 if the rowNumber is not used.
     *
     *  @return true if the requested cursor position is valid; false otherwise.
     *
     *  @exception  IOException  If an error occurs while communicating with the server.
     *  @exception  MEException  If an error occurs while processing the ToolboxME request.
     **/
    private boolean positionCursor(int action, int rowNumber) throws IOException, MEException
    {
        if (system_ == null)
            throw new MEException("Result set is closed.", MEException.RESULT_SET_CLOSED);

        synchronized(system_)
        {
            system_.toServer_.writeInt(action);
            
            system_.toServer_.writeInt(transactionID_);
            system_.toServer_.flush();

            if (action == MEConstants.SQL_ABSOLUTE)
                system_.toServer_.writeInt(rowNumber);

            int retVal = system_.fromServer_.readInt();

            if (retVal == MEConstants.SQL_POSITION_CURSOR_SUCCESSFUL)
            {
                boolean success = system_.fromServer_.readBoolean();
                
                return success;
            }
            else
            {
                throw new MEException(system_.fromServer_.readUTF(), retVal);
            }
        }
    }
}
